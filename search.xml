<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F18%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据分析1.工具Jupyter Notebook 运行命令 ：jupyter notebook 快捷键： Enter : 转入编辑模式 Shift-Enter : 运行本单元，选中下个单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在其下插入新单元 A : 在上方插入新单元 B : 在下方插入新单元 D,D : 删除选中的单元 Tab : 代码补全或缩进 M ： 单元转入markdown状态 shift-Tab : 提示 Ctrl-A ：全选 Ctrl -Z : 复原 1234567%time 运行计时,耗时长的代码%timeit (准确点)，耗时短的代码%matoplotlib 数据可视化%who 快速查看当前会话的所有变量与函数%who_ls 返回一个列表，，函数 %lsmagic 列出所有魔法命令 2.numpy 导入库 import numpy as np 创建ndarray 12345678910注意： &quot;- numpy默认ndarray的所有元素的类型是相同的&quot;, &quot;- 如果传进来的列表中包含不同的类型，则统一为同一类型，优先级str&gt;float&gt;int&quot; data = [1,2,3,4] nd = np.array(data) nd nd.dtype : 数据分析，分析的是什么类型的数据 nd.shape : 数据形状 数据可视化包 12345import matplotlib.pyplot as plt%matplotlib inlineplt.imread()plt.imshow() np.ones() ,np.zeros() ,np.full( fill_value) fill_value 填值 np.reshape() 重新定义形状，给数组一个新的形状而不改变其数据 np.eye() 矩阵 单元矩阵 numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 在指定的间隔内返回均匀间隔的数字。 np.arange( ) np.random.randint(a, b, size=(c, d)) #指定生成随机数范围和生成的多维数组大小 np.random.randn(d0, d1, …, dn) 标准正太分布 ,数据就是两边低中间高的数据 np.random.normal(mean,stdev,size) 给出均值为mean，标准差为stdev的高斯随机数（场），当size赋值时，例如：size=100，表示返回100个高斯随机数 np.random.random() 生成0到1的随机数，左闭右开 astype( “uint8”) 将数据转换成uint8 3.ndarray的属性与基本操作 4个必记参数 ： ndim维度 shape形状(各种维度的长度) size总长度 dtype 元素类型 索引 ：一维与列表完全一致，多维时同理 nd[1] nd[1,1] 根据索引修改数据 nd[2,2] =1000 切片 ： 一维与列表完全一致，多维时同理 广播机制 ： 如果赋值的数据不充分的话，会自动填充 变形 ： 使用reshape函数，注意参数是一个tuple 级联 np.concatenate() 级联的参数是一个列表，一定要加中括号或者小括号 ​ 维度必须相同 ，形状相符 ​ 级联的方向默认是shape这个tuple的第一个值所代表的维度方向 ​ 可通过axis 参数改变级联的方向 np.hstack 水平级联 二维变一维 np.vstack 垂直级联 一维变二维 切分 np.split np.vsplit np.hsplit ndarray 聚合操作 axis参数：当axis=0时，对列进行聚合操作；当axis=1时，对行进行聚合操作。求和np.sum： np.sum和np.nansum的区别 nan not a number 最大最小值np.max/np.min: 平均值np.mean： 矩阵操作 ndarray的矩阵操作广播机制： 规则一：为缺失的维度补1(维度只能相差1) 规则二：缺失元素用已有元素补充 规则三：缺失维度的矩阵只能有一行或者一列 ​ 算数运算 np.add(a+b) / a+b 矩阵积 np.dot() ndarray排序1.快速排序：np.sort()与ndarray.sort()都可以，但有区别：np.sort()不改变输入ndarray.sort()本地处理，不占用空间，但改变输 2.部分排序：np.partition(a,k)有的时候我们不是对全部数据感兴趣，我们可能只对最小或最大的一部分感兴趣。当k为正时，我们想要得到最小的k个数 , 当k为负时，我们想要得到最大的k个数： 4 cv2 人脸更换 opencv : 计算机视觉库 终端下载 : pip install opencv_python cv2在读的时候采用的是BGR 例子 ： 123456789101112sanpang = cv2.imread(&quot;./cv2_change_head/j.jpg&quot;)plt.imshow(sanpang[::,::,::-1])#CascadeClassifier:用来处理算法的类cascade = cv2.CascadeClassifier()#加载现成的算法cascade.load(&apos;./cv2_change_head/haarcascade_frontalface_default.xml&apos;)#使用人脸识别的类进行识别face = cascade.detectMultiScale(sanpang)face 5. pandas的数据结构导入 import pandas as pd ​ import pandas import Series ,DataFrame Series ​ Series 是一种类似与一维数组的对象，由两个部分组成： values 一组数据(ndarray 类型) index 相关的数据索引标签 1.创建Series (一一对应，不能多也不能少 （索引和value值）) ​ (1) 由列表或numpy数组创建 ，默认索引为 0 – N-1的整数型索引 ​ 例： s = Series([1,2,4]) ​ s= Series(np.aarray([1,2,3]), index=list(“abc”)) ​ (2) 由字典创建 (指定索引可多可少，多得情况补上NaN) ​ s = Series (data ={“a”:10,”b”:22,”c”:33},index ={“a”,”pi”,”c”} 2 .Series的索引和切片 ​ 可以使用中括号取单个索引（此时返回的是元素类型），或者中括号里一个列表取多 个索引（此时返回的仍然是一个Series类型）。分为显示索引和隐式索引： (1) 显式索引： - 使用index中的元素作为索引值 - 使用.loc[]（推荐） 注意，此时是闭区间 ​ (2) 隐式索引： - 使用整数作为索引值 - 使用.iloc[]（推荐） 注意，此时是半开区间 ​ 3 .Series 的基本概念 1234567891011121314151617181920212223(1) 可以把Series看成一个定长的有序字典 (2)可以通过shape，size，index,values等得到series的属性 (3)可以通过head() , tail()快速查看Series对象的样式 data.head() 参数可以设置数量 data.tail() (4)当索引没有对应的值时，可能出现缺失数据显示NaN（not a number）的情况 (5) 可以使用pd.isnull()，pd.notnull()，或自带isnull(),notnull()函数检测缺失数据 #通过isnull这个函数获取boolean数据的值， 可以把它当成一个检索 会取出为True的数据，也就是空值， 对空值进行赋值 例子： ind = s.isnull() s[ind] = np.nan (6)Series对象本身及其实例都有一个name属性 s = Series(data = np.random.randint(0,150,size = 5), index = [&quot;张三&quot;,&quot;李 四&quot;,&quot;Sara&quot;,&quot;Lisa&quot;,&quot;Michael&quot;] ) s.name = &quot;Python&quot; s ​ 4 .Series 的运算 ​ (1) 适用于numpy的数组运算也适用于Series ​ 加减乘除 ： add subtract multiply divide ​ (2) series之间的运算 ： 运算中自动对齐不同索引的数据 ​ 如果索引不对应，补NaN ​ 要想保留所有的index,则需要使用 .add()函数 二 .DataFrame ​ DataFrame是一个【表格型】的数据结构，可以看做是【由Series组成的字典】（共用同一个 索引）。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。 行索引：index 列索引：columns 值：values（numpy的二维数组） 创建 123456df1 = DataFrame(&#123;&apos;Python&apos;:[99,101,120,78], &quot;数学&quot;:[120,136,141,129], &quot;语文&quot;:[123,114,130,117]&#125;, index = list(&quot;abcd&quot;), columns = [&quot;Python&quot;,&quot;数学&quot;,&quot;语文&quot;,&quot;英语&quot;])df1行还是一对一的， 列可多可少 2 .DataFrame属性 ​ values , columns , index , shape 3 . DataFrame的索引 ​ (1) 对列进行索引 - 通过类似字典的方式 df2[&quot;python&quot;] 两列数据： df2[[&quot;Python&quot;,&quot;php&quot;]] - 通过属性的方式 - 列切片是不行的 可以将DataFrame的列获取为一个Series。返回的Series拥有原DataFrame相同的索引，且name属性也已经设置好了，就是相应的列名。 ​ ​ (2) 对行进行索引 ​ #行索引不能使用中括号！！！！！！ - 使用.ix[]来进行行索引 - 使用.loc[]加index来进行行索引 #对行数据进行切片, 左闭右闭 df2.loc[&quot;a&quot;:&quot;b&quot;] - 使用.iloc[]加整数来进行行索引 df2.iloc[0:3] #左闭右开的情况 #loc全部是左闭右闭 在切片的时候 iloc全部是左闭右开的 同样返回一个Series，index为原来的columns。 ​ (3) 对元素索引的方法 - 使用列索引 - 使用行索引(iloc[3,1]相当于两个参数;iloc[[3,3]] 里面的[3,3]看做一个参数) - 使用values属性（二维numpy数组） ​ df2.loc[“a”,”Java”]#总结：进行元素索引的时候，老老实实的行是行，列是列 【注意】直接用中括号时： 索引表示的是列索引 切片表示的是行切片 4 .DataFrame之间的运算 （1） DataFrame之间的运算 同Series一样： 在运算中自动对齐不同索引的数据 如果索引不对应，则补NaN 例： df1.add(df2, fill_value=0) fill_value 添值 （2） Series与DataFrame之间的运算（注意axis 轴） 【重要】 使用Python操作符：以行为单位操作（参数必须是行），对所有行都有效。（类似于numpy中二维数组与一维数组的运算，但可能出现NaN） 使用pandas操作函数： axis=0：以列为单位操作（参数必须是列），对所有列都有效。 axis=1：以行为单位操作（参数必须是行），对所有行都有效。 三 . 处理丢失数据 ​ numpy 中： 123456789101112131415161718192021有两种丢失数据 ： None np.nan(NaN) 1.None None是Python自带的，其类型为python object。因此，None不能参与到任何计算中。 object类型的运算要比int类型的运算慢得多 计算不同数据类型求和时间 %timeit np.arange(1e5,dtype=xxx).sum() 2.np.nan(NaN) np.nan是浮点类型，能参与到计算中。但计算的结果总是NaN。 但可以使用np.nan*()函数来计算nan，此时视nan为0。 pandas中None和np.nan都视作np.nan 123456例子 ：df = DataFrame([[10,20,57,np.nan,None], [22,33,56,12,None], [np.nan,1,2,3,4]], index = list(&quot;abc&quot;), columns = [&quot;Python&quot;,&quot;Java&quot;,&quot;数学&quot;,&quot;物理&quot;,&quot;H5&quot;])#三行五列df Python JAVA 数学 物理 H5 a 10.0 20 57 NaN NaN b 22.0 33 56 12.0 NaN c NaN 1 2 3.0 4.0 pandas中None与np.nan的操作 ​ isnull() 1总结：isnull().any() 查看数据 行或者列 是否有空值 ​ notnull() 1总结： isnull和any 使用 notnull和all使用 ​ dropna() 过滤丢失数据 1参数 how = &quot;all&quot; axis ​ fillna() 填冲充丢数据 12345可以选择前向填充还是后向填充前 :df3.fillna(method=&quot;ffill&quot;) #forward后 :df3.fillna(method=&quot;bfill&quot;) #back左 : df3.fillna(method=&quot;bfill&quot;,axis = 1) 右 :df3.fillna(method=&quot;ffill&quot;,axis = 1) 12#扩展cond = (df3 &gt;= 10).all(axis = 1) 6.pandas层次化索引​ 1.创建多层行索引 ​ (1) 隐式构造 ​ 最常见的方法是给DataFrame构造函数的index参数传递两个或者更多的数组 ​ 1234567891011121314151617181920#隐式创建s = Series(data = [1,2,3,&quot;a&quot;], index = [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;期中&quot;,&quot;期末&quot;,&quot;期中&quot;,&quot;期末&quot;]])s#二层索引df = DataFrame(data = [1,2,3,&quot;a&quot;], index = [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;期中&quot;,&quot;期末&quot;,&quot;期中&quot;,&quot;期末&quot;]], columns = [&quot;Python&quot;])df#三层索引df = DataFrame(data = np.random.randint(0,150,size = 8), index = [[&apos;a&apos;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;], [&apos;期中&apos;,&quot;期中&quot;,&quot;期末&quot;,&quot;期末&quot;,&apos;期中&apos;,&quot;期中&quot;,&quot;期末&quot;,&quot;期末&quot;], [&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;]], columns = [&quot;Python&quot;]) ​ (2)显示构造pd.MultiIndex ​ 使用数组 123456df1 = DataFrame(data = np.random.randint(0,150,size = (8,4)), index = pd.MultiIndex.from_arrays([[&apos;a&apos;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;], [&apos;期中&apos;,&quot;期中&quot;,&quot;期末&quot;,&quot;期末&quot;,&apos;期中&apos;,&quot;期中&quot;,&quot;期末&quot;,&quot;期末&quot;], [&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;]]), columns = [&quot;Python&quot;,&quot;h5&quot;,&quot;php&quot;,&quot;go&quot;])df1 使用tuple 1234df3 = DataFrame(np.random.randint(0,150,size = 4), index = pd.MultiIndex.from_tuples([(&quot;a&quot;,1),(&quot;a&quot;,2),(&quot;b&quot;,1),(&quot;b&quot;,2)]), columns = [&quot;Python&quot;])df3 使用product (最简单，推荐使用) 1234df4 = DataFrame(np.random.randint(0,150,size = (8,2)), index = pd.MultiIndex.from_product([list(&quot;abcd&quot;), [&quot;期中&quot;,&quot;期末&quot;]]), columns = [&apos;Python&apos;,&quot;数学&quot;])df4 ​ 多层列索引 ​ 除了行索引index ,列索引columns也能用同样的方法创建多层索引 多层索引对象的索引与切片操作 ​ (1) 对于Series来说：直接中括号[]与使用.loc()完全一样,因此推荐使用中括号索引和括号 ​ ​ （2） DataFrame的操作 ​ . 可以直接使用列名称来进行索引 ​ . 使用行索引需要ix( ) , loc() 函数 推荐使用loc()函数 注意在对行索引的时候，若一级行索引还有多个，对二级行索引会遇到问题！也就是说，无法直接对二级索引进行索引，必须让二级索引变成一级索引后才能对其进行索引！ 123df4[&quot;Python&quot;][&quot;a&quot;,&quot;期末&quot;]df4.loc[&quot;a&quot;].loc[&quot;期末&quot;][&quot;Python&quot;] 索引的堆 stack( level = * ) 【小技巧】使用stack()的时候，level等于哪一个，哪一个就消失，出现在行里。 ​ unstack() ​【小技巧】使用unstack()的时候，level等于哪一个，哪一个就消失，出现在列里。 聚合操作 【注意】 需要指定axis 【小技巧】和unstack()相反，聚合的时候，axis等于哪一个，哪一个就保留。 所谓的聚合操作：平均数，方差，最大值，最小值…… ​ 123df4.div(10, axis = &quot;index&quot;)df4.sum(axis = 1)df4.std() #标准差：表示的是数据的离散程度 ​ pandas 的拼接操作 ​ 级联 ： pd.concat pd.append(追加，只能行追加) ​ 合并 ： pd.merge ,pd.join ​ 12pd.concat = (objs ,axis = 0,join=&apos;outer&apos; ,join_axes=None,ignore_index=False,keys=None,levels=None,names=None,verify_integrity =False,copy= True) | 参数 | 说明 || —————- | —————————————- || objs | 参与连接的列表或字典，且列表或字典里的对象是pandas数据类型，唯一必须给定的参数 || axis=0 | 指明连接的轴向，0是纵轴，1是横轴，默认是0 || join | ‘inner’（交集）内链接，‘outer’（并集）外连接，默认是‘outer’指明轴向索引的索引是交集还是并集 || join_axis | 指明用于其他n-1条轴的索引（层次化索引，某个轴向有多个索引），不执行交并集 || keys | 与连接对象有关的值，用于形成连接轴向上的层次化索引（外层索引），可以是任意值的列表或数组、元组数据、数组列表（如果将levels设置成多级数组的话） || levels | 指定用作层次化索引各级别（内层索引）上的索引，如果设置keys的话 || names | 用于创建分层级别的名称，如果设置keys或levels的话 || verify_integrity | 检查结果对象新轴上的重复情况，如果发横则引发异常，默认False，允许重复 || ignore_index | 不保留连接轴上的索引，产生一组新索引range（total_length） | ​ pd.merge() 函数参数 一对一，一对多，多对多 | 参数 | 说明 || ———– | —————————————- || left | 参与合并的左侧DataFrame || right | 参与合并的右侧DataFrame || how | 连接方式：‘inner’（默认）；还有，‘outer’、‘left’、‘right’ || on | 用于连接的列名，必须同时存在于左右两个DataFrame对象中，如果位指定，则以left和right列名的交集作为连接键 || left_on | 左侧DataFarme中用作连接键的列 || right_on | 右侧DataFarme中用作连接键的列 || left_index | 将左侧的行索引用作其连接键 || right_index | 将右侧的行索引用作其连接键 || sort | 根据连接键对合并后的数据进行排序，默认为True。有时在处理大数据集时，禁用该选项可获得更好的性能 || suffixes | 字符串值元组，用于追加到重叠列名的末尾，默认为（‘_x’,‘_y’）.例如，左右两个DataFrame对象都有‘data’，则结果中就会出现‘data_x’，‘data_y’ || | | ​ set_index() 、重新设置行索引 ​ query() 查询 7.pandas数据处理1.删除重复元素 ​ 使用duplicated()函数检测重复的行，返回元素为布尔类型的Series对象，每个元素对应一行，如果该行不是第一次出现，则元素为True ​ 使用drop_duplicates()函数删除重复的行 映射 ​ 映射的含义：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定 需要使用字典： map = { &apos;label1&apos;:&apos;value1&apos;, &apos;label2&apos;:&apos;value2&apos;, ... } ` 包含三种操作： replace()函数：替换元素 最重要：map()函数：新建一列 ​ 由已有的列生成新的一列 map()函数中可以使用lambda函数 函数还可以传 一个回调函数 transform()和map()类似 rename()函数：替换索引 ​ 异常值检测和处理 ​ #对数据进行过滤#std标准差，主要是看数据的稳定性 ​ 删除特定索引df.drop(labels,inplace = True) ​ 4.排序 ​ (1）使用.take()函数排序， ​ df. take([2,4,5] ) 根据索引取值 ​ （2) 可以借助np.random.permutation()函数随机排序 ​ (3)当DataFrame规模足够大时，直接使用np.random.randint()函数，就配合take()函数实现随机抽样 数据聚合【重点】 数据聚合是数据处理的最后一步，通常是要使每一个数组生成一个单一的数值。 数据分类处理： 分组：先把数据分为几组 用函数处理：为不同组的数据应用不同的函数以转换数据 合并：把不同组得到的结果合并起来 数据分类处理的核心： groupby()函数 分组 groupby 之后，是聚合操作 高级数据集合(不用) ​ ### 可以使用transform和apply实现相同功能 12df.groupby([&quot;color&quot;]).transform(sum)df.groupby([&quot;color&quot;])[[&quot;price&quot;,&quot;weight&quot;]].apply(sum) Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线形图(不重) 123456s = Series([80,82,97,89,78,73,66], name = &quot;数学&quot;, index = list(&quot;abcdefg&quot;))s线性图： s.plot() 柱状图：s.plot(kind = &quot;bar&quot;) barh(反向) 横坐标没dx ，不会支持中文DataFrame: df.plot() 直方图 ​ 直方图，是一种特殊形状的柱状图 直方图又叫密度图 ​ s.hist(bins = 20) ​ bins 取值 1:1-1:2 ​ 随机数百分比密度图 s.plot(kind = ‘kde’)#kde 内核： 专门画密度图的 ​ 这两种图表经常被画在一起。直方图以规格化形式给出（以便给出面元化密度），然后再在其上绘制核密度估计。接下来来看一个由两个不同的标准正态分布组成的的双峰分布 np.random.normal()正太分布函数 直方图hist，函数中必须添加属性normed = True 8. scipy 123scipy.fftpack模块用来计算快速傅里叶变换 速度比传统傅里叶变换更快，是对之前算法的改进 图片是二维数据，注意使用fftpack的二维转变方法 使用傅里叶变换。把数据变成信号数据 fftpack.fft2() ​ 反向傅里叶变换 fftpack.ifft2() 1np.real() plt.figure() 尺寸 数值积分，求解圆周率 1使用scipy.integrate进行积分，调用quad()方法 scipy文件输入/输出 ​ from scipy import io ​ 随机生成数组，使用scipy中的io.savemat()保存 文件格式是.mat，标准的二进制文件 123io.savemat(&quot;./1811.mat&quot;, &#123;&quot;nd&quot;:nd&#125;)io.loadmat(&quot;./1811.mat&quot;)[&quot;nd&quot;] 读取数据 读写图片使用scipy中 misc.imread()/imsave() ​ misc.imrotate ( ) 旋转图片 ​ .resize() , imfilter() 图片处理 ​ ndimage 处理图片的包 ​ 使用scipy.misc.face(gray=True)获取图片，使用ndimage移动坐标、旋转图片、切割图片、 缩放图片 123ndimage.shift() 移动坐标ndimage.rotate() 旋转图片ndimage.zoom() 缩放图片 图片进行过滤 添加噪声，对噪声图片使用ndimage中的高斯滤波、中值滤波、signal中维纳滤波进行处理使图片变清楚 9.matplotlib Matplotlib基础知识： Matplotlib中的基本图表包括的元素 ​ x轴和y轴​ 水平和垂直的轴线 ​ x轴和y轴刻度​ 刻度标示坐标轴的分隔，包括最小刻度和最大刻度 ​ x轴和y轴刻度标签​ 表示特定坐标轴的值 ​ 绘图区域​ 实际绘图的区域 (1) plt.plot(x,y,format_string,**kwargs) ​ x轴数据，y轴数据，format_string控制曲线的格式字串 ​ format_string 由颜色字符，风格字符，和标记字符 ​ **kwargs:第二组或更多，(x,y,format_string) ​ 123456789color:控制颜色，color=’green’ linestyle:线条风格，linestyle=’dashed’ marker:标记风格，marker = ‘o’ markerfacecolor:标记颜色，markerfacecolor = ‘blue’ markersize:标记尺寸，markersize = ‘20’ plt.grid(True) #设置网格线 lw代表linewidth，线的粗细 alpha表示线的明暗程度 plt.title() #标题 12345678910111213fontsize设置字体大小，默认12，可选参数 [&apos;xx-small&apos;, &apos;x-small&apos;, &apos;small&apos;, &apos;medium&apos;, &apos;large&apos;,&apos;x-large&apos;, &apos;xx-large&apos;]fontweight设置字体粗细，可选参数 [&apos;light&apos;, &apos;normal&apos;, &apos;medium&apos;, &apos;semibold&apos;, &apos;bold&apos;, &apos;heavy&apos;, &apos;black&apos;]fontstyle设置字体类型，可选参数[ &apos;normal&apos; | &apos;italic&apos; | &apos;oblique&apos; ]，italic斜体，oblique倾斜verticalalignment设置水平对齐方式 ，可选参数 ： &apos;center&apos; , &apos;top&apos; , &apos;bottom&apos; ,&apos;baseline&apos; horizontalalignment设置垂直对齐方式，可选参数：left,right,centerrotation(旋转角度)可选参数为:vertical,horizontal 也可以为数字alpha透明度，参数值0至1之间backgroundcolor标题背景颜色bbox给标题增加外框 ，常用参数如下： boxstyle方框外形 facecolor(简写fc)背景颜色 edgecolor(简写ec)边框线条颜色 edgewidth边框线条大小 plt.xlabel()/ylabel() #设置轴标签 参数：rotation 旋转度数 plt.legend(loc=’upper left’) #设置legend显示，并指定位置 1234567891011121314| 字符串 | 数值 | 字符串 | 数值 || :-------------: |:-----------:| :-----:| :-----:|| best | 0 | center left | 6 || upper right | 1 | center right | 7 || upper left | 2 | lower center | 8 || lower left | 3 | upper center | 9 || lower right | 4 | center | 10 || right | 5 | ncol控制图例中有几列 mode = （可拉伸的） bbox_to_anchor (锚点) 例子： bbox_to_anchor= [o,2,1,0.1] 前两个值是坐标点，第三个值宽度，最后一个是距离y轴的距离 facecolor 背景颜色 plt.show() #显示图像 设置坐标轴范围 除了plt.axis方法，还可以通过xlim，ylim方法设置坐标轴范围 12添加子视图axes1 = figure.add_subplot(1,3,1) #表示一行三列第一个 ​ 不同程度的破折线 ​ dashes =[ ] #注意偶数 ​ （2）保存图片 ​ plt.savefig() （3）三种设置方式 ​ 1.向方法传入关键字参数 ​ 2.使用setp()方法 ​ 3 .对实例使用一系列的setter方法 (4) x,y轴坐标刻度 123locs, labels = plt.xticks() # 不传入任何参数，xticks()会返回当前刻度的位置和标签Π，α，β，----》 [&quot;$\pi$&quot;] 2D图形 (1) 直方图]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
