<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo + Next 主题博客分享功能]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F03%2F17%2FHexo%20%2B%20Next%20%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Hexo + Next 主题博客分享功能next主题自带的文章分享功能（百度分享不支持https，虽有解决方法单较为麻烦，其他分享插件也较为麻烦,见我另一篇）这里我采用的是needmoreshare2,首先在themes/next/下执行：可以先删除next/source/lib 下的needsharebutton文件1git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton然后配置主题文件：12345678910111213141516needmoreshare2: enable: true postbottom: enable: true #是否开启博客分享按钮 options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: true #网站分享按钮 options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,FacebookNeedMoreShare2 支持的参数有以下一些iconStyle：分享图标的形式，取值有 default, box；boxForm：分享图标的排列样式，取值有 horizontal, vertical；position：点按按钮之后，分享图标出现的位置，默认是 bottomCenter，取值可以是以下组合 top/middle/bottom + Left/Center/Right；networks：希望分享到哪些社交网络，默认是 &#39;Weibo,Wechat,Douban,QQZone,Twitter,Pinterest,Facebook,GooglePlus,Reddit,Linkedin,Tumblr,Evernote&#39;，还可以有 RenRen；url：默认是 location.href；title：默认是document.title；image：默认从 meta[property=&quot;og:image&quot;] 或 meta[name=&quot;twitter:image&quot;] 取值；description：默认从 meta[property=&quot;og:description&quot;] 或 meta[name=&quot;twitter:description&quot;] 取值。]]></content>
      <categories>
        <category>Hexo</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>needmoreshare2分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F23%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[python面向对象知识 1、构造方法123456789101112131415161718192021222324252627282930313233343536373839class Person(object): # 后期除非定义单例类，否则基本不用写 # 构造方法包括创建对象和初始化对象，在python当中，分为两步执行：先执行__new__方法，然后执行__init__方法； # __init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。 # __new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例，是个静态方法。 #__new__在__init__之前被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。 def __new__(cls, *args, **kwargs): # 调用父类中的__new__方法开辟内存空间 return super(Person, cls).__new__(cls) # super() 函数是用于调用父类(超类)的一个方法。 # self表示一个具体的实例本身。 # cls表示这个类本身。 #类属性 def __init__(self, name, age, height, weight): # 对象属性，只能对象调用 self.name = name self.age = age self.height = height self.weight = weight def say(self): # 对象方法中可以调用对象属性 return "my name is %s, I am %d years old"%(self.name, self.age)#创建对象时给每个对象的属性赋值per1 = Person("lilei", 20, 170, 80)per2 = Person("hanmeimei", 18, 165, 50)print(per1.name)print(per2.name)# print(Person.name) #类中没有name属性，且类名无法调用对象属性print(per1.say())print(per2.say())# 延伸# __new__()方法：是一个类方法，返回一个对象的实例，在使用类实例化对象时自动调用，目的是在堆区开辟一片内存空间，会在__init__之前调用# 使用：创建单例类2、访问限制123456789101112131415161718192021222324252627282930313233343536373839class Person(object): # 在python中，变量名类似__xxxx__的，属于特殊变量，特殊变量时可以直接访问的，不是私有变量 def __init__(self, name, age, height, weight, money): self.name = name self.age = age self.height = height self.weight = weight # 在python中_xxx变量，这样的实例变量不是可以直接访问的。但是，按照约定俗成的规定，当看到这样的变量时，意思是虽然我可以被外部直接访问，但是请把我视为私有变量，不要在外部随意访问 self._temp = 2 # 特殊变量 self.__test__ = 1 #如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线 #python中，示例的变量以__开头，就变成了一个私有属性(private)，只能在内部访问，外部无法访问 #不能再外部直接访问__money的原因是python解释器对外把__money属性改成了_Person__money。所以任然可以用_Person__money来直接访问，但是强烈建议不要这么做，因为不同版本的python解释器可能会把__money改成不同的属性名 self.__money = money #定义公有方法间接访问私有属性 def getMoney(self): return self.__money def setMoney(self, money): if money &gt;= 0: self.__money = money def say(self): return "my name is %s, I am %d years old"%(self.name, self.age) 实例属性与类属性：由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量：class Student(object): def __init__(self, name): self.name = names = Student('Bob')s.score = 90但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：class Student(object): name = 'Student'当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。3、@property123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Person(object): def __init__(self, name, age, height, weight, money): self.name = name self.age = age self.height = height self.weight = weight self.__money = money #把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作 @property def money(self): return self.__money @money.setter def money(self, value): if value &lt; 0: self.__money = 0 else: self.__money = value #定义公有方法间接访问私有属性 # def getMoney(self): # return self.__money # def setMoney(self, money): # if money &lt; 0: # self.__money = 0 # else: # self.__money = money def say(self): return "my name is %s, I am %d years old"%(self.name, self.age)per = Person("lilei", 20, 170, 80, 100)print("-------------")#想让访问私有属性的方式类似访问普通属性，需要使用@property#让私有属性可以使用点语法print(per.money) #相当于执行money()per.money = -10 #相当于执行money(-10)print(per.money)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-------------1000只定义getter方法，不定义setter方法就是一个只读属性：class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth上面的birth是可读写属性，而age就是一个只读属性。4、动态给实例添加属性与方法并使用slots槽1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Person(object): __slots__ = ("name", "age", "height", "weight", "money", "run") def __init__(self, name, age, height, weight): self.name = name self.age = age self.height = height self.weight = weight def say(self): return "my name is %s, I am %d years old"%(self.name, self.age)per1 = Person("lilei", 20, 170, 80)per2 = Person("hanmeimei", 18, 165, 50)print(per1.say())#实例化一个对象后，可以给对象绑定任何的属性和方法，这就是动态语言的灵活性#如果属性不存在，则变为增加属性per1.money = 100print(per1.money)#增加方法def run(self): print("run")from types import MethodTypeper1.run = MethodType(run, per1)per1.run()#注意：给一个实例对象绑定的属性和方法对另一个实例对象没有影响# print(per2.money)#需求：给所有的实例都绑定属性和方法#解决：给类绑定就可以了#注意：不仅仅给已存在的对象会绑定，未创建的对象也绑定了Person.faceValue = 100 #增加属性def play(self): print("play")Person.play = playprint(per1.faceValue, per2.faceValue)per1.play()per2.play()per3 = Person("laowang", 50, 167, 60)print(per3.faceValue)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;my name is lilei, I am 20 years old100run100 100playplay100#思考：想限制实例的属性，不让对象随意添加属性，只能添加我们规定一些属性#解决：在定义类时，定义一个特殊属性__slots__，限制该类实例能添加的属性想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称然后，我们试试：&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'&gt;&gt;&gt; s.age = 25 # 绑定属性'age'&gt;&gt;&gt; s.score = 99 # 绑定属性'score'Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'score'由于'score'没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的5、单例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374单例：是一种软件设计模式，该模式的主要目的是确保一个类只有一个实例存在实现单例的方式： 1、使用模块 2、使用__new__ 3、使用装饰器 4、使用元类 1、使用模块card.py:class Card(object): def __init__(self, cardId, passwd, money): self.cardId = cardId self.passwd = passwd self.money = moneyc = Card("888888", "666666", 10000)main.py:# -*- coding:utf-8 -*-from card import c'''原理：python的模块就是天然的单例模式，因为模块的在第一次导入时，会产生.pyc文件，但第二次导入时，就会直接加载.pyc文件，而不会再执行模块代码。'''2、使用__new__class Card(object): def __new__(cls, *args, **kwargs): # 每一次实例化的时候，都只返回instance同一个对象 if not hasattr(cls, "instance"): #hasattr() 函数用于判断对象是否包含对应的属性。 cls.instance = super(Card, cls).__new__(cls) return cls.instancecard1 = Card()card1.passwd = "666666"card2 = Card()print(card2.passwd)print(card1 is card2)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;666666True3、使用装饰器def singleton(cls): instances = &#123;&#125; def getinstance(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) # self表示一个具体的实例本身。 # cls表示这个类本身。 #判断一个变量是否是某个类型可以用isinstance()判断： isinstance(b, Animal) # isinstance(a, list) return instances[cls] return getinstance@singletonclass Card(object): pass@singletonclass Person(object): passc1 = Card()c2 = Card()print(c1 is c2)p1 = Person()p2 = Person()print(p1 is p2)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;TrueTrue4、使用元类6、重写repr与str函数1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-class Person(object): #重写：将继承的方法重写写一遍，在原有的功能基础上添加一些新的功能 def __init__(self, name, age, height, weight): self.name = name self.age = age self.height = height self.weight = weight def say(self): return "my name is %s, I am %d years old"%(self.name, self.age) #需求：打印该类型的对象时，想打印出对象的各个属性值 #解决：重写__str__方法 #__str__()方法：在调用print打印对象时自动调用 #是显示给用户的 def __str__(self): return "name:%s\nage:%d\nheight:%.2f\nweight:%.2f"%(self.name, self.age, self.height, self.weight) #是给机器用的，在python解释器里直接敲对象后回车自动调用 def __repr__(self): return "name:%s\nage:%d\nheight:%.2f\nweight:%.2f"%(self.name, self.age, self.height, self.weight)per = Person("lilei", 20, 170, 80)print(per)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;name:lileiage:20height:170.00weight:80.00__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：class Student(object): def __init__(self, name): self.name = name def __str__(self): return 'Student object (name=%s)' % self.name __repr__ = __str__7、继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#类定义class people: #定义类属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print("%s 说: 我 %d 岁。" %(self.name,self.age)) #单继承示例class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade)) s = student('ken',10,60,3)s.speak()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;ken 说: 我 10 岁了，我在读 3 年级#类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print("%s 说: 我 %d 岁。" %(self.name,self.age)) #单继承示例class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = '' name = '' def __init__(self,n,t): self.name = n self.topic = t def speak(self): print("我叫 %s，我是一个演说家，我演讲的主题是 %s"%(self.name,self.topic)) #多重继承class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample("Tim",25,80,4,"Python")test.speak() #方法名同，默认调用的是在括号中排前地父类的方法&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;我叫 Tim，我是一个演说家，我演讲的主题是 Python类的专有方法：__init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 函数调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__div__: 除运算__mod__: 求余运算__pow__: 乘方8、MRO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118'''概念：方法解析顺序，是python中用于处理二义性问题的算法二义性： 问题一：有两个基类A和B，A和B都定义了f()方法，C继承A和B，那么调用C的f()方法时会出现不确定性 问题二：有一个基类A，定义了方法f()，B类和C类都继承自A类，D类继承了B类和C类，此时出现一个问题，D类不知道该继承B的f()还是C的f()C++解决二义性： 问题1：通过同名覆盖的方法解决的 问题2：通过虚继承来解决python解决二义性： 通过C3算法避免二义性的情况经历的过程： 1、python2.2以前的版本（经典类时代） 2、python2.2版本（新式类诞生） 3、python2.3到python2.7（经典类、新式类和平发展） 4、python3至今（新式类一统江山）'''1、python2.2以前的版本（经典类时代）#特性：经典类是一种没有继承的类，对象类型都是type类型，如果经典类被作为父类，子类调用父类的构造函数时会出错# class A:# pass'''mro的方法为深度优先算法(DFS):1、把根阶段压入栈中2、每次从栈中弹出一个元素，搜索所有它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱3、找到所有的元素时结束程序4、如果遍历整个树还没有找到，程序结束'''#查看经典类的MRO顺序import inspectclass D: passclass C(D): passclass B(D): passclass A(B, C): passprint(inspect.getmro(A))'''第一种：正常继承模式，两个互不相关的类的多继承，这种请求DFS顺序正常的，没有引起任何问题第二种：菱形继承模式，存在公共父类D类的多继承，这种情况DFS必须经过公共父类（D），如果公共父类D中有一些初始化属性和方法，但是子类C有重写了这些属性和方法，那么按照DFS的顺序必定是先找到D的属性和方法，那么C的属性或方法将永远用不到，导致C只能继承无法重写。''' 2、python2.2版本（新式类诞生）#新式类特性：为了是类和内置类型更加统一，引入新式类。新式类的每个类都继承于一个基类，可以是自定义的类或者其他类，默认是object。子类可以调用父类的构造函数# 新式类代码查看mro顺序class D(object): passclass C(D): passclass B(D): passclass A(B, C): passprint(A.__mro__)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class 'object'&gt;)'''两种MRO算法 如果是经典类使用DFS 如果是新式类使用BFS(广度优化算法) 1、把根节点放到队列末尾 2、每次从队列的头部取一个元素，搜索所有它下一级的元素，把这些元素放到队列的末尾，并把这个元素记为它下一级元素的前驱。 3、找到所有的元素时结束程序 4、如果遍历整个树还没有找到，程序结束 ''''''第一种：看起来正常，但实际上感觉别扭，比如B继承D的f()函数，恰巧C中页实现了f()函数，那么BFS顺序先访问B然后在访问C，f()函数会选择C的，这种应该先从B和B的父类开始找才是正确的顺序，称为单调性第二种：菱形模式下BFS解决了DFS查找顺序的问题，但是它也违背了单调性3、python2.3到python2.7（经典类、新式类和平发展）特性：在之前的BFS算法存在很大的问题，从python2.3开始新式类的MRO算法使用了C3算法，C3算法解决了单调性问题和只能继承无法重写的问题4、python3至今（新式类一统江山）# -*- coding:utf-8 -*-class D(object): passclass E(object): passclass F(object): passclass C(D, F): passclass B(E, D): passclass A(B, C): passprint(A.__mro__)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;, &lt;class 'object'&gt;)Process finished with exit code 0'''解决的问题 1、单调性问题 2、不能重写的问题''''''拓扑排序： 对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序''''''抽象模拟 首先找入读为 0 的点，只有一个A，把A拿出来，把A相关的边剪切掉，再找入度点为0的点，有两个(B、C)，根据最左侧原则，拿B，此时的顺序AB，剪切B相关的边。此时入度点为0的点有E和C。取最左侧是E，此时排序为ABE，剪切E的相关边。此时只有一个入度点为0的点为C，取C,此时顺序为ABEC，剪切C相关的边得到两个入度点为0的点（D、F），取最左侧的D点，此时顺序为ABECD，剪切D相关的边，此时只剩下F的入度点为0了，取F，此时顺序为ABECDF，再裁剪相关边，最后一个入度点为0的点为object，再去object，此时顺序为ABECDFobject'''9、栈和队列123456789101112131415161718192021222324252627282930313233343536373839# -*- coding:utf-8 -*-'''#栈#特点：先进后出mystack = []#压栈mystack.append(1)print(mystack)mystack.append(2)print(mystack)mystack.append(3)print(mystack)mystack.append(4)print(mystack)#出栈mystack.pop()print(mystack)mystack.pop()print(mystack)mystack.pop()print(mystack)mystack.pop()print(mystack)'''#队列#特点：先进先出from collections import dequequeue = deque([1,2,3,4])#进队queue.append(5)print(queue)queue.append(6)print(queue)#出队print(queue.popleft())print(queue)print(queue.popleft())print(queue)10、运算符重载12345678910111213141516class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Vector(7,8)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 主题添加分享功能]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F23%2F2019-1-24%20Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD%20121259%2F</url>
    <content type="text"><![CDATA[Next主题添加分享功能next主题自带的jiathis分享功能（2018年4月已停止 http://www.lwd3699.com/keji/1564.html）打开主next主题配置文件_config.yml ,搜索jiathis,改为true即可123# Warning: JiaThis does not support https.(不支持https)jiathis: true ##uid: Get this uid from http://www.jiathis.com/next主题自带的百度分享功能：参考链接：https://asdfv1929.github.io/2018/05/25/baidu-share/打开主next主题配置文件_config.yml ,搜索baidushare,添加如下配置（其中 type 亦可以选择 slide)：123baidushare: type: button baidushare: true #新增由于baidushare不支持https，解决方法便是，将static文件夹解压保存至themes\next\source目录下 。static文件链接： https://github.com/hrwhisper/baiduShare修改文件：themes\next\layout_partials\share\baidushare.swig将文件 末尾 部分的代码进行修改：1.src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];改为： 1.src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];最后重新生成下，就能展示分享功能了。NexT主题添加ShareSDK的分享：传送门 ：ShareSDK​]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>ShareSDK分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 主题添加站内搜索功能]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F23%2FNext%20%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Next 主题添加站内搜索功能详细请看：https://github.com/wzpan/hexo-generator-search安装 hexo-generator-searchdb, 站点根目录执行以下命令1npm install hexo-generator-searchdb --save编辑 站点配置文件, 新增以下内容到任意位置12345search: path: search.xml field: post format: html limit: 10000编辑 主题配置文件, 启用本地搜索功能123# Local searchlocal_search: enable: true可能出现的问题如果出现点击搜索一直停留在加载状态，可能是文件编码问题，可以在本地测试时访问根目录下 search.xml 文件1localhost:4000/search.xml查看报错信息]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析基础知识]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F23%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据分析1.工具Jupyter Notebook运行命令 ：jupyter notebook快捷键：Enter : 转入编辑模式Shift-Enter : 运行本单元，选中下个单元Ctrl-Enter : 运行本单元Alt-Enter : 运行本单元，在其下插入新单元A : 在上方插入新单元B : 在下方插入新单元D,D : 删除选中的单元Tab : 代码补全或缩进M ： 单元转入markdown状态shift-Tab : 提示Ctrl-A ：全选Ctrl -Z : 复原1234567%time 运行计时,耗时长的代码%timeit (准确点)，耗时短的代码%matoplotlib 数据可视化%who 快速查看当前会话的所有变量与函数%who_ls 返回一个列表，，函数 %lsmagic 列出所有魔法命令2.numpy导入库import numpy as np创建ndarray12345678910注意： "- numpy默认ndarray的所有元素的类型是相同的", "- 如果传进来的列表中包含不同的类型，则统一为同一类型，优先级str&gt;float&gt;int" data = [1,2,3,4] nd = np.array(data) nd nd.dtype : 数据分析，分析的是什么类型的数据 nd.shape : 数据形状数据可视化包12345import matplotlib.pyplot as plt%matplotlib inlineplt.imread()plt.imshow()np.ones() ,np.zeros() ,np.full( fill_value) fill_value 填值np.reshape() 重新定义形状，给数组一个新的形状而不改变其数据np.eye() 矩阵 单元矩阵numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)在指定的间隔内返回均匀间隔的数字。np.arange( )np.random.randint(a, b, size=(c, d)) #指定生成随机数范围和生成的多维数组大小np.random.randn(d0, d1, …, dn) 标准正太分布 ,数据就是两边低中间高的数据np.random.normal(mean,stdev,size) 给出均值为mean，标准差为stdev的高斯随机数（场），当size赋值时，例如：size=100，表示返回100个高斯随机数np.random.random() 生成0到1的随机数，左闭右开astype( “uint8”) 将数据转换成uint83.ndarray的属性与基本操作4个必记参数 ： ndim维度 shape形状(各种维度的长度) size总长度 dtype 元素类型索引 ：一维与列表完全一致，多维时同理nd[1] nd[1,1]根据索引修改数据 nd[2,2] =1000切片 ： 一维与列表完全一致，多维时同理广播机制 ： 如果赋值的数据不充分的话，会自动填充变形 ： 使用reshape函数，注意参数是一个tuple级联np.concatenate() 级联的参数是一个列表，一定要加中括号或者小括号​ 维度必须相同 ，形状相符​ 级联的方向默认是shape这个tuple的第一个值所代表的维度方向​ 可通过axis 参数改变级联的方向np.hstack 水平级联 二维变一维np.vstack 垂直级联 一维变二维切分np.split np.vsplit np.hsplitndarray 聚合操作axis参数：当axis=0时，对列进行聚合操作；当axis=1时，对行进行聚合操作。求和np.sum： np.sum和np.nansum的区别 nan not a number最大最小值np.max/np.min:平均值np.mean：矩阵操作ndarray的矩阵操作广播机制：规则一：为缺失的维度补1(维度只能相差1)规则二：缺失元素用已有元素补充规则三：缺失维度的矩阵只能有一行或者一列​算数运算 np.add(a+b) / a+b矩阵积 np.dot()ndarray排序1.快速排序：np.sort()与ndarray.sort()都可以，但有区别：np.sort()不改变输入ndarray.sort()本地处理，不占用空间，但改变输2.部分排序：np.partition(a,k)有的时候我们不是对全部数据感兴趣，我们可能只对最小或最大的一部分感兴趣。当k为正时，我们想要得到最小的k个数 , 当k为负时，我们想要得到最大的k个数：4 cv2 人脸更换opencv : 计算机视觉库终端下载 : pip install opencv_pythoncv2在读的时候采用的是BGR例子 ：123456789101112sanpang = cv2.imread("./cv2_change_head/j.jpg")plt.imshow(sanpang[::,::,::-1])#CascadeClassifier:用来处理算法的类cascade = cv2.CascadeClassifier()#加载现成的算法cascade.load('./cv2_change_head/haarcascade_frontalface_default.xml')#使用人脸识别的类进行识别face = cascade.detectMultiScale(sanpang)face5. pandas的数据结构导入 import pandas as pd​ import pandas import Series ,DataFrameSeries​ Series 是一种类似与一维数组的对象，由两个部分组成：values 一组数据(ndarray 类型)index 相关的数据索引标签1.创建Series (一一对应，不能多也不能少 （索引和value值）)​ (1) 由列表或numpy数组创建 ，默认索引为 0 – N-1的整数型索引​ 例： s = Series([1,2,4])​ s= Series(np.aarray([1,2,3]), index=list(“abc”))​ (2) 由字典创建 (指定索引可多可少，多得情况补上NaN)​ s = Series (data ={“a”:10,”b”:22,”c”:33},index ={“a”,”pi”,”c”}2 .Series的索引和切片​ 可以使用中括号取单个索引（此时返回的是元素类型），或者中括号里一个列表取多 个索引（此时返回的仍然是一个Series类型）。分为显示索引和隐式索引：(1) 显式索引：- 使用index中的元素作为索引值 - 使用.loc[]（推荐） 注意，此时是闭区间​ (2) 隐式索引：- 使用整数作为索引值 - 使用.iloc[]（推荐） 注意，此时是半开区间​ 3 .Series 的基本概念1234567891011121314151617181920212223(1) 可以把Series看成一个定长的有序字典 (2)可以通过shape，size，index,values等得到series的属性 (3)可以通过head() , tail()快速查看Series对象的样式 data.head() 参数可以设置数量 data.tail() (4)当索引没有对应的值时，可能出现缺失数据显示NaN（not a number）的情况 (5) 可以使用pd.isnull()，pd.notnull()，或自带isnull(),notnull()函数检测缺失数据 #通过isnull这个函数获取boolean数据的值， 可以把它当成一个检索 会取出为True的数据，也就是空值， 对空值进行赋值 例子： ind = s.isnull() s[ind] = np.nan (6)Series对象本身及其实例都有一个name属性 s = Series(data = np.random.randint(0,150,size = 5), index = ["张三","李 四","Sara","Lisa","Michael"] ) s.name = "Python" s​4 .Series 的运算​ (1) 适用于numpy的数组运算也适用于Series​ 加减乘除 ： add subtract multiply divide​ (2) series之间的运算 ： 运算中自动对齐不同索引的数据​ 如果索引不对应，补NaN​ 要想保留所有的index,则需要使用 .add()函数二 .DataFrame​ DataFrame是一个【表格型】的数据结构，可以看做是【由Series组成的字典】（共用同一个 索引）。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。行索引：index列索引：columns值：values（numpy的二维数组）创建123456df1 = DataFrame(&#123;'Python':[99,101,120,78], "数学":[120,136,141,129], "语文":[123,114,130,117]&#125;, index = list("abcd"), columns = ["Python","数学","语文","英语"])df1行还是一对一的， 列可多可少2 .DataFrame属性​ values , columns , index , shape3 . DataFrame的索引​ (1) 对列进行索引- 通过类似字典的方式 df2[&quot;python&quot;] 两列数据： df2[[&quot;Python&quot;,&quot;php&quot;]] - 通过属性的方式 - 列切片是不行的 可以将DataFrame的列获取为一个Series。返回的Series拥有原DataFrame相同的索引，且name属性也已经设置好了，就是相应的列名。​​ (2) 对行进行索引​ #行索引不能使用中括号！！！！！！- 使用.ix[]来进行行索引 - 使用.loc[]加index来进行行索引 #对行数据进行切片, 左闭右闭 df2.loc[&quot;a&quot;:&quot;b&quot;] - 使用.iloc[]加整数来进行行索引 df2.iloc[0:3] #左闭右开的情况 #loc全部是左闭右闭 在切片的时候 iloc全部是左闭右开的 同样返回一个Series，index为原来的columns。​ (3) 对元素索引的方法- 使用列索引 - 使用行索引(iloc[3,1]相当于两个参数;iloc[[3,3]] 里面的[3,3]看做一个参数) - 使用values属性（二维numpy数组） ​ df2.loc[“a”,”Java”]#总结：进行元素索引的时候，老老实实的行是行，列是列【注意】直接用中括号时：索引表示的是列索引切片表示的是行切片4 .DataFrame之间的运算（1） DataFrame之间的运算同Series一样：在运算中自动对齐不同索引的数据如果索引不对应，则补NaN例： df1.add(df2, fill_value=0) fill_value 添值（2） Series与DataFrame之间的运算（注意axis 轴）【重要】使用Python操作符：以行为单位操作（参数必须是行），对所有行都有效。（类似于numpy中二维数组与一维数组的运算，但可能出现NaN）使用pandas操作函数：axis=0：以列为单位操作（参数必须是列），对所有列都有效。 axis=1：以行为单位操作（参数必须是行），对所有行都有效。 三 . 处理丢失数据​ numpy 中：123456789101112131415161718192021有两种丢失数据 ： None np.nan(NaN) 1.None None是Python自带的，其类型为python object。因此，None不能参与到任何计算中。 object类型的运算要比int类型的运算慢得多 计算不同数据类型求和时间 %timeit np.arange(1e5,dtype=xxx).sum() 2.np.nan(NaN) np.nan是浮点类型，能参与到计算中。但计算的结果总是NaN。 但可以使用np.nan*()函数来计算nan，此时视nan为0。pandas中None和np.nan都视作np.nan123456例子 ：df = DataFrame([[10,20,57,np.nan,None], [22,33,56,12,None], [np.nan,1,2,3,4]], index = list("abc"), columns = ["Python","Java","数学","物理","H5"])#三行五列dfPythonJAVA数学物理H5a10.02057NaNNaNb22.0335612.0NaNcNaN123.04.0pandas中None与np.nan的操作​ isnull()1总结：isnull().any() 查看数据 行或者列 是否有空值​ notnull()1总结： isnull和any 使用 notnull和all使用​ dropna() 过滤丢失数据1参数 how = "all" axis​ fillna() 填冲充丢数据12345可以选择前向填充还是后向填充前 :df3.fillna(method="ffill") #forward后 :df3.fillna(method="bfill") #back左 : df3.fillna(method="bfill",axis = 1) 右 :df3.fillna(method="ffill",axis = 1)12#扩展cond = (df3 &gt;= 10).all(axis = 1)6.pandas层次化索引​ 1.创建多层行索引​ (1) 隐式构造​ 最常见的方法是给DataFrame构造函数的index参数传递两个或者更多的数组​1234567891011121314151617181920#隐式创建s = Series(data = [1,2,3,"a"], index = [["a","a","b","b"],["期中","期末","期中","期末"]])s#二层索引df = DataFrame(data = [1,2,3,"a"], index = [["a","a","b","b"],["期中","期末","期中","期末"]], columns = ["Python"])df#三层索引df = DataFrame(data = np.random.randint(0,150,size = 8), index = [['a',"a","a","a","b","b","b","b"], ['期中',"期中","期末","期末",'期中',"期中","期末","期末"], ["一单元","二单元","一单元","二单元","一单元","二单元","一单元","二单元"]], columns = ["Python"])​ (2)显示构造pd.MultiIndex​ 使用数组123456df1 = DataFrame(data = np.random.randint(0,150,size = (8,4)), index = pd.MultiIndex.from_arrays([['a',"a","a","a","b","b","b","b"], ['期中',"期中","期末","期末",'期中',"期中","期末","期末"], ["一单元","二单元","一单元","二单元","一单元","二单元","一单元","二单元"]]), columns = ["Python","h5","php","go"])df1使用tuple1234df3 = DataFrame(np.random.randint(0,150,size = 4), index = pd.MultiIndex.from_tuples([("a",1),("a",2),("b",1),("b",2)]), columns = ["Python"])df3使用product (最简单，推荐使用)1234df4 = DataFrame(np.random.randint(0,150,size = (8,2)), index = pd.MultiIndex.from_product([list("abcd"), ["期中","期末"]]), columns = ['Python',"数学"])df4​多层列索引​ 除了行索引index ,列索引columns也能用同样的方法创建多层索引多层索引对象的索引与切片操作​ (1) 对于Series来说：直接中括号[]与使用.loc()完全一样,因此推荐使用中括号索引和括号​​ （2） DataFrame的操作​ . 可以直接使用列名称来进行索引​ . 使用行索引需要ix( ) , loc() 函数 推荐使用loc()函数注意在对行索引的时候，若一级行索引还有多个，对二级行索引会遇到问题！也就是说，无法直接对二级索引进行索引，必须让二级索引变成一级索引后才能对其进行索引！123df4["Python"]["a","期末"]df4.loc["a"].loc["期末"]["Python"]索引的堆stack( level = * )【小技巧】使用stack()的时候，level等于哪一个，哪一个就消失，出现在行里。​ unstack()​【小技巧】使用unstack()的时候，level等于哪一个，哪一个就消失，出现在列里。聚合操作【注意】需要指定axis【小技巧】和unstack()相反，聚合的时候，axis等于哪一个，哪一个就保留。所谓的聚合操作：平均数，方差，最大值，最小值……​123df4.div(10, axis = "index")df4.sum(axis = 1)df4.std() #标准差：表示的是数据的离散程度​pandas 的拼接操作​ 级联 ： pd.concat pd.append(追加，只能行追加)​ 合并 ： pd.merge ,pd.join​12pd.concat = (objs ,axis = 0,join='outer' ,join_axes=None,ignore_index=False,keys=None,levels=None,names=None,verify_integrity =False,copy= True)| 参数 | 说明 || —————- | —————————————- || objs | 参与连接的列表或字典，且列表或字典里的对象是pandas数据类型，唯一必须给定的参数 || axis=0 | 指明连接的轴向，0是纵轴，1是横轴，默认是0 || join | ‘inner’（交集）内链接，‘outer’（并集）外连接，默认是‘outer’指明轴向索引的索引是交集还是并集 || join_axis | 指明用于其他n-1条轴的索引（层次化索引，某个轴向有多个索引），不执行交并集 || keys | 与连接对象有关的值，用于形成连接轴向上的层次化索引（外层索引），可以是任意值的列表或数组、元组数据、数组列表（如果将levels设置成多级数组的话） || levels | 指定用作层次化索引各级别（内层索引）上的索引，如果设置keys的话 || names | 用于创建分层级别的名称，如果设置keys或levels的话 || verify_integrity | 检查结果对象新轴上的重复情况，如果发横则引发异常，默认False，允许重复 || ignore_index | 不保留连接轴上的索引，产生一组新索引range（total_length） |​pd.merge() 函数参数一对一，一对多，多对多| 参数 | 说明 || ———– | —————————————- || left | 参与合并的左侧DataFrame || right | 参与合并的右侧DataFrame || how | 连接方式：‘inner’（默认）；还有，‘outer’、‘left’、‘right’ || on | 用于连接的列名，必须同时存在于左右两个DataFrame对象中，如果位指定，则以left和right列名的交集作为连接键 || left_on | 左侧DataFarme中用作连接键的列 || right_on | 右侧DataFarme中用作连接键的列 || left_index | 将左侧的行索引用作其连接键 || right_index | 将右侧的行索引用作其连接键 || sort | 根据连接键对合并后的数据进行排序，默认为True。有时在处理大数据集时，禁用该选项可获得更好的性能 || suffixes | 字符串值元组，用于追加到重叠列名的末尾，默认为（‘_x’,‘_y’）.例如，左右两个DataFrame对象都有‘data’，则结果中就会出现‘data_x’，‘data_y’ || | |​ set_index() 、重新设置行索引​ query() 查询7.pandas数据处理1.删除重复元素​ 使用duplicated()函数检测重复的行，返回元素为布尔类型的Series对象，每个元素对应一行，如果该行不是第一次出现，则元素为True​ 使用drop_duplicates()函数删除重复的行映射​ 映射的含义：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定需要使用字典：map = {&apos;label1&apos;:&apos;value1&apos;, &apos;label2&apos;:&apos;value2&apos;, ... } `包含三种操作：replace()函数：替换元素最重要：map()函数：新建一列​ 由已有的列生成新的一列 map()函数中可以使用lambda函数 函数还可以传 一个回调函数 transform()和map()类似rename()函数：替换索引​异常值检测和处理​ #对数据进行过滤#std标准差，主要是看数据的稳定性​ 删除特定索引df.drop(labels,inplace = True)​ 4.排序​ (1）使用.take()函数排序，​ df. take([2,4,5] ) 根据索引取值​ （2) 可以借助np.random.permutation()函数随机排序​ (3)当DataFrame规模足够大时，直接使用np.random.randint()函数，就配合take()函数实现随机抽样数据聚合【重点】数据聚合是数据处理的最后一步，通常是要使每一个数组生成一个单一的数值。数据分类处理：分组：先把数据分为几组用函数处理：为不同组的数据应用不同的函数以转换数据合并：把不同组得到的结果合并起来数据分类处理的核心：groupby()函数 分组 groupby 之后，是聚合操作 高级数据集合(不用)​ ### 可以使用transform和apply实现相同功能12df.groupby(["color"]).transform(sum)df.groupby(["color"])[["price","weight"]].apply(sum)Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线形图(不重)123456s = Series([80,82,97,89,78,73,66], name = "数学", index = list("abcdefg"))s线性图： s.plot() 柱状图：s.plot(kind = "bar") barh(反向) 横坐标没dx ，不会支持中文DataFrame: df.plot()直方图​ 直方图，是一种特殊形状的柱状图 直方图又叫密度图​ s.hist(bins = 20)​ bins 取值 1:1-1:2​ 随机数百分比密度图 s.plot(kind = ‘kde’)#kde 内核： 专门画密度图的​ 这两种图表经常被画在一起。直方图以规格化形式给出（以便给出面元化密度），然后再在其上绘制核密度估计。接下来来看一个由两个不同的标准正态分布组成的的双峰分布np.random.normal()正太分布函数直方图hist，函数中必须添加属性normed = True8. scipy123scipy.fftpack模块用来计算快速傅里叶变换 速度比传统傅里叶变换更快，是对之前算法的改进 图片是二维数据，注意使用fftpack的二维转变方法使用傅里叶变换。把数据变成信号数据 fftpack.fft2()​ 反向傅里叶变换 fftpack.ifft2()1np.real() plt.figure() 尺寸数值积分，求解圆周率1使用scipy.integrate进行积分，调用quad()方法scipy文件输入/输出​ from scipy import io​ 随机生成数组，使用scipy中的io.savemat()保存 文件格式是.mat，标准的二进制文件123io.savemat("./1811.mat", &#123;"nd":nd&#125;)io.loadmat("./1811.mat")["nd"] 读取数据读写图片使用scipy中 misc.imread()/imsave()​ misc.imrotate ( ) 旋转图片​ .resize() , imfilter()图片处理​ ndimage 处理图片的包​ 使用scipy.misc.face(gray=True)获取图片，使用ndimage移动坐标、旋转图片、切割图片、 缩放图片123ndimage.shift() 移动坐标ndimage.rotate() 旋转图片ndimage.zoom() 缩放图片图片进行过滤添加噪声，对噪声图片使用ndimage中的高斯滤波、中值滤波、signal中维纳滤波进行处理使图片变清楚9.matplotlibMatplotlib基础知识： Matplotlib中的基本图表包括的元素​ x轴和y轴​ 水平和垂直的轴线​ x轴和y轴刻度​ 刻度标示坐标轴的分隔，包括最小刻度和最大刻度​ x轴和y轴刻度标签​ 表示特定坐标轴的值​ 绘图区域​ 实际绘图的区域(1) plt.plot(x,y,format_string,**kwargs)​ x轴数据，y轴数据，format_string控制曲线的格式字串​ format_string 由颜色字符，风格字符，和标记字符​ **kwargs:第二组或更多，(x,y,format_string)​123456789color:控制颜色，color=’green’ linestyle:线条风格，linestyle=’dashed’ marker:标记风格，marker = ‘o’ markerfacecolor:标记颜色，markerfacecolor = ‘blue’ markersize:标记尺寸，markersize = ‘20’plt.grid(True) #设置网格线lw代表linewidth，线的粗细alpha表示线的明暗程度plt.title() #标题12345678910111213fontsize设置字体大小，默认12，可选参数 ['xx-small', 'x-small', 'small', 'medium', 'large','x-large', 'xx-large']fontweight设置字体粗细，可选参数 ['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']fontstyle设置字体类型，可选参数[ 'normal' | 'italic' | 'oblique' ]，italic斜体，oblique倾斜verticalalignment设置水平对齐方式 ，可选参数 ： 'center' , 'top' , 'bottom' ,'baseline' horizontalalignment设置垂直对齐方式，可选参数：left,right,centerrotation(旋转角度)可选参数为:vertical,horizontal 也可以为数字alpha透明度，参数值0至1之间backgroundcolor标题背景颜色bbox给标题增加外框 ，常用参数如下： boxstyle方框外形 facecolor(简写fc)背景颜色 edgecolor(简写ec)边框线条颜色 edgewidth边框线条大小plt.xlabel()/ylabel() #设置轴标签 参数：rotation 旋转度数plt.legend(loc=’upper left’) #设置legend显示，并指定位置1234567891011121314| 字符串 | 数值 | 字符串 | 数值 || :-------------: |:-----------:| :-----:| :-----:|| best | 0 | center left | 6 || upper right | 1 | center right | 7 || upper left | 2 | lower center | 8 || lower left | 3 | upper center | 9 || lower right | 4 | center | 10 || right | 5 | ncol控制图例中有几列 mode = （可拉伸的） bbox_to_anchor (锚点) 例子： bbox_to_anchor= [o,2,1,0.1] 前两个值是坐标点，第三个值宽度，最后一个是距离y轴的距离 facecolor 背景颜色plt.show() #显示图像设置坐标轴范围除了plt.axis方法，还可以通过xlim，ylim方法设置坐标轴范围12添加子视图axes1 = figure.add_subplot(1,3,1) #表示一行三列第一个​ 不同程度的破折线​ dashes =[ ] #注意偶数​（2）保存图片​ plt.savefig()（3）三种设置方式​ 1.向方法传入关键字参数​ 2.使用setp()方法​ 3 .对实例使用一系列的setter方法(4) x,y轴坐标刻度123locs, labels = plt.xticks() # 不传入任何参数，xticks()会返回当前刻度的位置和标签Π，α，β，----》 ["$\pi$"]2D图形(1) 直方图]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>numpy</tag>
        <tag>matoplotlib可视化</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo网站时间修改]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F08%2F23%2Fhexo%E7%BD%91%E7%AB%99%E6%97%B6%E9%97%B4%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[HEXO 网站时间修改网站建立时间​ 这个时间将在站点的底部显示，例如 © 2017 - 2018。 编辑 主题配置文件，_config.yml搜索 since​ 修改参数即可网站已运行时间编辑主题源文件./themes/layout/_parrials/footer.swing找到以下代码区块1234&#123;% if theme.footer.theme.enable %&#125;/* ... */&#123;% endif %&#125;HLJS | COPY在 &lt;/div&gt; 之前添加123&lt;span&gt; | &lt;/span&gt;&lt;span id="showDays"&gt;&lt;/span&gt;LANG-HTML | COPY在该文件末尾处添加12345678910111213141516171819202122232425&lt;script&gt; var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var birthDay = Date.UTC(2016,07,30,00,00,00); // 这里设置建站时间 setInterval(function() &#123; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = now - birthDay; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById('showDays').innerHTML="本站已运行 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒"; &#125;, 1000);&lt;/script&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题个性化之自动更换背景图片]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F01%2F25%2FNext%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[Next主题个性化之自动更换背景图片如果觉得next的空白主题看腻了或者太多人用觉得不够个性化，那么不妨试试自动更新背景图片（简单且酷）。实现的原理：调用了网站的接口。自动更换背景的实现是修改添加背景的css样式实现。图片来源是 ：https://source.unsplash.com/这个网站，里面不仅免费提供了很多高清美图，而且还提供api接口调用，实在是良心。1 .修改背景样式修改themes\next\source\css\ _custom\custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：body {background:url(https://source.unsplash.com/random/1600x900);background-repeat: no-repeat;background-attachment:fixed;background-position:50% 50%;}如果自己不喜欢这个网址提供的图片做背景，那么修改url()里面的路径即可。repeat、attachment、position就是调整图片的位置，不重复出现、不滚动等等。2.修改不透明度完成这一步其实背景就会自动更换了，但是会出现一个问题，因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。那么就需要调整背景的不透明度了。同样是修改themes\next\source\css\ _custom\custom.styl文件。在后面添加如下代码body {background:url(https://source.unsplash.com/random/1600x900);background-repeat: no-repeat;background-attachment:fixed;background-position:50% 50%;}.content-wrap {opacity: 0.86;}(实际需要根据选择的主题来添加)然后 hexo clean hexo g hexo d 便可以实现了参考链接：https://blog.csdn.net/mango_haoming/article/details/78473243]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT 项目开发流程]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F12%2F23%2FWork%2F</url>
    <content type="text"><![CDATA[Work项目开发流程产品经理PRD原型图开会项目评估能不能做多长时间做出来有什么风险UIDBA数据库工程师设计库，表后台设计库，设计表封装Api送测提交Bug修改Bug上Staging演示环境上线凌晨三点版本迭代未雨绸缪研究那些将使用但是还没有使用过的技术协作工具文档协作Google Document有道云协作Trello版本控制Git代码托管仓库GitHub码云gerritgitlabBug反馈平台Bugzilla用户，用户组可以按照应用分配bug为bug分级追踪bugBugly持续集成JenkinsOA管理员工出勤，请假打卡打指纹刷脸钉钉邮件系统企业邮箱记录项目活跃度统计工具自己通过中间件实现专门的统计平台实现友盟统计百度统计xxx统计统计工具项目分析淘票票用户端用户系统纯自己打造用户注册来的电影系统属于后台管理的跳转到选座购票根据时间，根据电影名，根据区域，筛选排期拿着电影ID去电影院中的排档表筛选影院系统属于后台管理的对影院的区域级联筛选，再加评分和综合排序跳转到选座购票影院已经确定可以根据时间和电影去排档中筛选购票选座系统对应的是排档，排档中包含影厅，影厅包含座位布局座位状态确定根据订单来修改座位状态已支付订单 status = 2 已支付懒修改来管理锁单查询锁单订单 status=0 已下单未付款，继续根据时间节点进行联合查询订单将座位号，排档，用户发送给服务器生成订单十五分钟过期有时间戳，当前时间 + 十五分钟锁单真实订单，只不过订单未支付，并且未锁单支付系统内嵌支付宝调用第三方支付宝积分系统点评系统电影院端用户系统电影院注册电影系统后台管理的放映厅影院自己的排档影厅 + 电影 + 时间 + 影院售票和用户的订单生成是一样的只不过订单的用户是default后台管理客户端用户系统只是辅助维护电影院用户辅助维护，认证，信息修改需要后端认证电影系统淘宝直接对接的订单系统都可以查看]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试中的公共问题]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F01%2F02%2F%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%85%AC%E5%85%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试中的公共问题计算机基础TCP/IP模型相关问题。建议阅读阮一峰的《互联网协议入门（一）》和《互联网协议入门（二）》。HTTP和HTTPS相关问题。建议阅读阮一峰的《HTTP 协议入门》和《SSL/TLS协议运行机制的概述》。Linux常用命令和服务。进程和线程之间的关系。什么时候用多线程？什么时候用多进程？。关系型数据库相关问题（ACID、事务隔离级别、锁、SQL优化）。非关系型数据库相关问题（CAP/BASE、应用场景）。Python基础开发中用过哪些标准库和三方库。标准库：sys / os / re / math / random / logging / json / pickle / shelve / socket / datetime / hashlib / configparser / urllib / itertools / collections / functools / threading / multiprocess / timeit / atexit / abc / asyncio / base64 / concurrent.futures / copy / csv / operator / enum / heapq / http / profile / pstats / ssl / unitest / uuid装饰器的作用、原理和实现。使用过哪些魔法方法。建议阅读《Python魔术方法指南》。生成式、生成器、迭代器的编写。列表、集合、字典的底层实现。垃圾回收相关问题。并发编程的相关问题。协程和异步I/O相关知识。Django和FlaskMVC架构（MTV）解决了什么问题。中间件的执行流程以及如何自定义中间件。REST数据接口如何设计（URL、域名、版本、过滤、状态码、安全性）。建议阅读阮一峰的《RESTful API设计指南》。使用ORM框架实现CRUD操作的相关问题。如何实现多条件组合查询 / 如何执行原生的SQL / 如何避免N+1查询问题如何执行异步任务和定时任务。如何实现页面缓存和查询缓存？缓存如何预热？爬虫相关Scrapy框架的组件和数据处理流程。爬取的目的（项目中哪些地方需要用到爬虫的数据）。使用的工具（抓包、下载、清理、存储、分析、可视化）。数据的来源（能够轻松的列举出10个网站）。数据的构成（抓取的某个字段在项目中有什么用）。反反爬措施（限速、请求头、Cookie池、代理池、Selenium、PhantomJS、RoboBrowser、TOR、OCR）。数据的体量（最后抓取了多少数据，多少W条数据或多少个G的数据）。后期数据处理（持久化、数据补全、归一化、格式化、转存、分类）。数据分析科学运算函数库（SciPy和NumPy常用运算）。数据分析库（Pandas中封装的常用算法）。常用的模型及对应的场景（分类、回归、聚类）。提取了哪些具体的指标。如何评价模型的优劣。每种模型实际操作的步骤，对结果如何评价。项目相关项目团队构成以及自己在团队中扮演的角色（在项目中的职责）。项目的业务架构（哪些模块及子模块）和技术架构（移动端、PC端、后端技术栈）。软件控制管理相关工具（版本控制、问题管理、持续集成）。核心业务实体及其属性，实体与实体之间的关系。用到哪些依赖库，依赖库主要解决哪方面的问题。项目如何部署上线以及项目的物理架构（Nginx、Gunicorn/uWSGI、Redis、MongoDB、MySQL、Supervisor等）。如何对项目进行测试，有没有做过性能调优。项目中遇到的困难有哪些，如何解决的。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About]]></title>
    <url>%2Flinchao1002.github.io%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[简介：星座：天秤座/Boy邮箱: linchao1002@qq.com歡迎收藏本站，下面留言會盡可能答復 (右下角可以实时联系哦，方便尽快回复你)]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Flinchao1002.github.io%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Flinchao1002.github.io%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
