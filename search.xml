<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo + Next 主题博客分享功能]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F03%2F17%2FHexo%20%2B%20Next%20%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Hexo + Next 主题博客分享功能next主题自带的文章分享功能（百度分享不支持https，虽有解决方法但较为麻烦，其他分享插件也较为麻烦,见我另一篇）这里我采用的是needmoreshare2,首先在themes/next/下执行：可以先删除next/source/lib 下的needsharebutton文件1git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton然后配置主题文件：12345678910111213141516needmoreshare2: enable: true postbottom: enable: true #是否开启博客分享按钮 options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: true #网站分享按钮 options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,FacebookNeedMoreShare2 支持的参数有以下一些iconStyle：分享图标的形式，取值有 default, box；boxForm：分享图标的排列样式，取值有 horizontal, vertical；position：点按按钮之后，分享图标出现的位置，默认是 bottomCenter，取值可以是以下组合 top/middle/bottom + Left/Center/Right；networks：希望分享到哪些社交网络，默认是 &#39;Weibo,Wechat,Douban,QQZone,Twitter,Pinterest,Facebook,GooglePlus,Reddit,Linkedin,Tumblr,Evernote&#39;，还可以有 RenRen；url：默认是 location.href；title：默认是document.title；image：默认从 meta[property=&quot;og:image&quot;] 或 meta[name=&quot;twitter:image&quot;] 取值；description：默认从 meta[property=&quot;og:description&quot;] 或 meta[name=&quot;twitter:description&quot;] 取值。]]></content>
      <categories>
        <category>Hexo</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>needmoreshare2分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F23%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[python面向对象知识 1、构造方法123456789101112131415161718192021222324252627282930313233343536373839class Person(object): # 后期除非定义单例类，否则基本不用写 # 构造方法包括创建对象和初始化对象，在python当中，分为两步执行：先执行__new__方法，然后执行__init__方法； # __init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。 # __new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例，是个静态方法。 #__new__在__init__之前被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。 def __new__(cls, *args, **kwargs): # 调用父类中的__new__方法开辟内存空间 return super(Person, cls).__new__(cls) # super() 函数是用于调用父类(超类)的一个方法。 # self表示一个具体的实例本身。 # cls表示这个类本身。 #类属性 def __init__(self, name, age, height, weight): # 对象属性，只能对象调用 self.name = name self.age = age self.height = height self.weight = weight def say(self): # 对象方法中可以调用对象属性 return "my name is %s, I am %d years old"%(self.name, self.age)#创建对象时给每个对象的属性赋值per1 = Person("lilei", 20, 170, 80)per2 = Person("hanmeimei", 18, 165, 50)print(per1.name)print(per2.name)# print(Person.name) #类中没有name属性，且类名无法调用对象属性print(per1.say())print(per2.say())# 延伸# __new__()方法：是一个类方法，返回一个对象的实例，在使用类实例化对象时自动调用，目的是在堆区开辟一片内存空间，会在__init__之前调用# 使用：创建单例类2、访问限制123456789101112131415161718192021222324252627282930313233343536373839class Person(object): # 在python中，变量名类似__xxxx__的，属于特殊变量，特殊变量时可以直接访问的，不是私有变量 def __init__(self, name, age, height, weight, money): self.name = name self.age = age self.height = height self.weight = weight # 在python中_xxx变量，这样的实例变量不是可以直接访问的。但是，按照约定俗成的规定，当看到这样的变量时，意思是虽然我可以被外部直接访问，但是请把我视为私有变量，不要在外部随意访问 self._temp = 2 # 特殊变量 self.__test__ = 1 #如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线 #python中，示例的变量以__开头，就变成了一个私有属性(private)，只能在内部访问，外部无法访问 #不能再外部直接访问__money的原因是python解释器对外把__money属性改成了_Person__money。所以任然可以用_Person__money来直接访问，但是强烈建议不要这么做，因为不同版本的python解释器可能会把__money改成不同的属性名 self.__money = money #定义公有方法间接访问私有属性 def getMoney(self): return self.__money def setMoney(self, money): if money &gt;= 0: self.__money = money def say(self): return "my name is %s, I am %d years old"%(self.name, self.age) 实例属性与类属性：由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量：class Student(object): def __init__(self, name): self.name = names = Student('Bob')s.score = 90但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：class Student(object): name = 'Student'当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。3、@property123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Person(object): def __init__(self, name, age, height, weight, money): self.name = name self.age = age self.height = height self.weight = weight self.__money = money #把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作 @property def money(self): return self.__money @money.setter def money(self, value): if value &lt; 0: self.__money = 0 else: self.__money = value #定义公有方法间接访问私有属性 # def getMoney(self): # return self.__money # def setMoney(self, money): # if money &lt; 0: # self.__money = 0 # else: # self.__money = money def say(self): return "my name is %s, I am %d years old"%(self.name, self.age)per = Person("lilei", 20, 170, 80, 100)print("-------------")#想让访问私有属性的方式类似访问普通属性，需要使用@property#让私有属性可以使用点语法print(per.money) #相当于执行money()per.money = -10 #相当于执行money(-10)print(per.money)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-------------1000只定义getter方法，不定义setter方法就是一个只读属性：class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth上面的birth是可读写属性，而age就是一个只读属性。4、动态给实例添加属性与方法并使用slots槽1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Person(object): __slots__ = ("name", "age", "height", "weight", "money", "run") def __init__(self, name, age, height, weight): self.name = name self.age = age self.height = height self.weight = weight def say(self): return "my name is %s, I am %d years old"%(self.name, self.age)per1 = Person("lilei", 20, 170, 80)per2 = Person("hanmeimei", 18, 165, 50)print(per1.say())#实例化一个对象后，可以给对象绑定任何的属性和方法，这就是动态语言的灵活性#如果属性不存在，则变为增加属性per1.money = 100print(per1.money)#增加方法def run(self): print("run")from types import MethodTypeper1.run = MethodType(run, per1)per1.run()#注意：给一个实例对象绑定的属性和方法对另一个实例对象没有影响# print(per2.money)#需求：给所有的实例都绑定属性和方法#解决：给类绑定就可以了#注意：不仅仅给已存在的对象会绑定，未创建的对象也绑定了Person.faceValue = 100 #增加属性def play(self): print("play")Person.play = playprint(per1.faceValue, per2.faceValue)per1.play()per2.play()per3 = Person("laowang", 50, 167, 60)print(per3.faceValue)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;my name is lilei, I am 20 years old100run100 100playplay100#思考：想限制实例的属性，不让对象随意添加属性，只能添加我们规定一些属性#解决：在定义类时，定义一个特殊属性__slots__，限制该类实例能添加的属性想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称然后，我们试试：&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'&gt;&gt;&gt; s.age = 25 # 绑定属性'age'&gt;&gt;&gt; s.score = 99 # 绑定属性'score'Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'score'由于'score'没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的5、单例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374单例：是一种软件设计模式，该模式的主要目的是确保一个类只有一个实例存在实现单例的方式： 1、使用模块 2、使用__new__ 3、使用装饰器 4、使用元类 1、使用模块card.py:class Card(object): def __init__(self, cardId, passwd, money): self.cardId = cardId self.passwd = passwd self.money = moneyc = Card("888888", "666666", 10000)main.py:# -*- coding:utf-8 -*-from card import c'''原理：python的模块就是天然的单例模式，因为模块的在第一次导入时，会产生.pyc文件，但第二次导入时，就会直接加载.pyc文件，而不会再执行模块代码。'''2、使用__new__class Card(object): def __new__(cls, *args, **kwargs): # 每一次实例化的时候，都只返回instance同一个对象 if not hasattr(cls, "instance"): #hasattr() 函数用于判断对象是否包含对应的属性。 cls.instance = super(Card, cls).__new__(cls) return cls.instancecard1 = Card()card1.passwd = "666666"card2 = Card()print(card2.passwd)print(card1 is card2)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;666666True3、使用装饰器def singleton(cls): instances = &#123;&#125; def getinstance(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) # self表示一个具体的实例本身。 # cls表示这个类本身。 #判断一个变量是否是某个类型可以用isinstance()判断： isinstance(b, Animal) # isinstance(a, list) return instances[cls] return getinstance@singletonclass Card(object): pass@singletonclass Person(object): passc1 = Card()c2 = Card()print(c1 is c2)p1 = Person()p2 = Person()print(p1 is p2)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;TrueTrue4、使用元类6、重写repr与str函数1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-class Person(object): #重写：将继承的方法重写写一遍，在原有的功能基础上添加一些新的功能 def __init__(self, name, age, height, weight): self.name = name self.age = age self.height = height self.weight = weight def say(self): return "my name is %s, I am %d years old"%(self.name, self.age) #需求：打印该类型的对象时，想打印出对象的各个属性值 #解决：重写__str__方法 #__str__()方法：在调用print打印对象时自动调用 #是显示给用户的 def __str__(self): return "name:%s\nage:%d\nheight:%.2f\nweight:%.2f"%(self.name, self.age, self.height, self.weight) #是给机器用的，在python解释器里直接敲对象后回车自动调用 def __repr__(self): return "name:%s\nage:%d\nheight:%.2f\nweight:%.2f"%(self.name, self.age, self.height, self.weight)per = Person("lilei", 20, 170, 80)print(per)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;name:lileiage:20height:170.00weight:80.00__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：class Student(object): def __init__(self, name): self.name = name def __str__(self): return 'Student object (name=%s)' % self.name __repr__ = __str__7、继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#类定义class people: #定义类属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print("%s 说: 我 %d 岁。" %(self.name,self.age)) #单继承示例class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade)) s = student('ken',10,60,3)s.speak()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;ken 说: 我 10 岁了，我在读 3 年级#类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print("%s 说: 我 %d 岁。" %(self.name,self.age)) #单继承示例class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = '' name = '' def __init__(self,n,t): self.name = n self.topic = t def speak(self): print("我叫 %s，我是一个演说家，我演讲的主题是 %s"%(self.name,self.topic)) #多重继承class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample("Tim",25,80,4,"Python")test.speak() #方法名同，默认调用的是在括号中排前地父类的方法&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;我叫 Tim，我是一个演说家，我演讲的主题是 Python类的专有方法：__init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 函数调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__div__: 除运算__mod__: 求余运算__pow__: 乘方8、MRO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118'''概念：方法解析顺序，是python中用于处理二义性问题的算法二义性： 问题一：有两个基类A和B，A和B都定义了f()方法，C继承A和B，那么调用C的f()方法时会出现不确定性 问题二：有一个基类A，定义了方法f()，B类和C类都继承自A类，D类继承了B类和C类，此时出现一个问题，D类不知道该继承B的f()还是C的f()C++解决二义性： 问题1：通过同名覆盖的方法解决的 问题2：通过虚继承来解决python解决二义性： 通过C3算法避免二义性的情况经历的过程： 1、python2.2以前的版本（经典类时代） 2、python2.2版本（新式类诞生） 3、python2.3到python2.7（经典类、新式类和平发展） 4、python3至今（新式类一统江山）'''1、python2.2以前的版本（经典类时代）#特性：经典类是一种没有继承的类，对象类型都是type类型，如果经典类被作为父类，子类调用父类的构造函数时会出错# class A:# pass'''mro的方法为深度优先算法(DFS):1、把根阶段压入栈中2、每次从栈中弹出一个元素，搜索所有它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱3、找到所有的元素时结束程序4、如果遍历整个树还没有找到，程序结束'''#查看经典类的MRO顺序import inspectclass D: passclass C(D): passclass B(D): passclass A(B, C): passprint(inspect.getmro(A))'''第一种：正常继承模式，两个互不相关的类的多继承，这种请求DFS顺序正常的，没有引起任何问题第二种：菱形继承模式，存在公共父类D类的多继承，这种情况DFS必须经过公共父类（D），如果公共父类D中有一些初始化属性和方法，但是子类C有重写了这些属性和方法，那么按照DFS的顺序必定是先找到D的属性和方法，那么C的属性或方法将永远用不到，导致C只能继承无法重写。''' 2、python2.2版本（新式类诞生）#新式类特性：为了是类和内置类型更加统一，引入新式类。新式类的每个类都继承于一个基类，可以是自定义的类或者其他类，默认是object。子类可以调用父类的构造函数# 新式类代码查看mro顺序class D(object): passclass C(D): passclass B(D): passclass A(B, C): passprint(A.__mro__)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class 'object'&gt;)'''两种MRO算法 如果是经典类使用DFS 如果是新式类使用BFS(广度优化算法) 1、把根节点放到队列末尾 2、每次从队列的头部取一个元素，搜索所有它下一级的元素，把这些元素放到队列的末尾，并把这个元素记为它下一级元素的前驱。 3、找到所有的元素时结束程序 4、如果遍历整个树还没有找到，程序结束 ''''''第一种：看起来正常，但实际上感觉别扭，比如B继承D的f()函数，恰巧C中页实现了f()函数，那么BFS顺序先访问B然后在访问C，f()函数会选择C的，这种应该先从B和B的父类开始找才是正确的顺序，称为单调性第二种：菱形模式下BFS解决了DFS查找顺序的问题，但是它也违背了单调性3、python2.3到python2.7（经典类、新式类和平发展）特性：在之前的BFS算法存在很大的问题，从python2.3开始新式类的MRO算法使用了C3算法，C3算法解决了单调性问题和只能继承无法重写的问题4、python3至今（新式类一统江山）# -*- coding:utf-8 -*-class D(object): passclass E(object): passclass F(object): passclass C(D, F): passclass B(E, D): passclass A(B, C): passprint(A.__mro__)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;, &lt;class 'object'&gt;)Process finished with exit code 0'''解决的问题 1、单调性问题 2、不能重写的问题''''''拓扑排序： 对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序''''''抽象模拟 首先找入读为 0 的点，只有一个A，把A拿出来，把A相关的边剪切掉，再找入度点为0的点，有两个(B、C)，根据最左侧原则，拿B，此时的顺序AB，剪切B相关的边。此时入度点为0的点有E和C。取最左侧是E，此时排序为ABE，剪切E的相关边。此时只有一个入度点为0的点为C，取C,此时顺序为ABEC，剪切C相关的边得到两个入度点为0的点（D、F），取最左侧的D点，此时顺序为ABECD，剪切D相关的边，此时只剩下F的入度点为0了，取F，此时顺序为ABECDF，再裁剪相关边，最后一个入度点为0的点为object，再去object，此时顺序为ABECDFobject'''9、栈和队列123456789101112131415161718192021222324252627282930313233343536373839# -*- coding:utf-8 -*-'''#栈#特点：先进后出mystack = []#压栈mystack.append(1)print(mystack)mystack.append(2)print(mystack)mystack.append(3)print(mystack)mystack.append(4)print(mystack)#出栈mystack.pop()print(mystack)mystack.pop()print(mystack)mystack.pop()print(mystack)mystack.pop()print(mystack)'''#队列#特点：先进先出from collections import dequequeue = deque([1,2,3,4])#进队queue.append(5)print(queue)queue.append(6)print(queue)#出队print(queue.popleft())print(queue)print(queue.popleft())print(queue)10、运算符重载12345678910111213141516class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Vector(7,8)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 主题添加站内搜索功能]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F23%2FNext%20%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Next 主题添加站内搜索功能详细请看：https://github.com/wzpan/hexo-generator-search安装 hexo-generator-searchdb, 站点根目录执行以下命令1npm install hexo-generator-searchdb --save编辑 站点配置文件, 新增以下内容到任意位置12345search: path: search.xml field: post format: html limit: 10000编辑 主题配置文件, 启用本地搜索功能123# Local searchlocal_search: enable: true可能出现的问题如果出现点击搜索一直停留在加载状态，可能是文件编码问题，可以在本地测试时访问根目录下 search.xml 文件1localhost:4000/search.xml查看报错信息]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx大全]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F23%2FNginx%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是一款轻量级的Web服务器/反向代理服务器以及电子邮件代理服务器，其特点是占用内存少，并发能力强，在同类型的网页服务器中表现优秀Nginx是由伊戈尔.塞索耶夫开发的，于2004年10月4日公开源码，以类BSD许可证形式发布Nginx因它的稳定性，丰富的功能，示例配置文件和低系统资源的消耗而闻名中国大陆使用Nginx的网站:淘宝，京东，腾讯，百度，新浪，网易…官网http://nginx.org/中文资料http://www.nginx.cn/doc/index.htmlhttp://tengine.taobao.org/book/为什么选择Nginx作为We服务器：相比Apache，Nginx使用资源更少，支持更多的并发连接，体现更高的效率，使Nginx倍受欢迎，能够支持高达50000个并发连接数的响应作为负载均衡服务器：Nginx既可以在内部直接支持Redis和PHP，也可以支持作为HTTP代理服务器对外进行服务，Nginx使用C编写，不论是系统资源开销还是CPU使用效率都处理的非常优秀Nginx安装非常简单，配置文件非常简洁，Bug非常少：Nginx启动非常容易，并且几乎可以做到7 * 24小时不间断运行，即使运行数个月也不需要重新启动#Nginx安装Nginx安装主要有两种方式方法一、通过操作系统的包管理器进行安装：https://www.jianshu.com/p/96691511295f方法二、在官方网站下载源代码，编译安装：https://www.jianshu.com/p/96691511295f启动Nginxnginx [ -c configpath]信息查看nginx -vnginx -V控制Nginxnginx -s signalstop 快速关闭quit 优雅的关闭reload 重新加载配置通过系统管理systemctl status nginx 查看nginx状态systemctl start nginx 启动nginx服务systemctl stop nginx 关闭nginx服务systemctl enable nginx 设置开机自启systemctl disable nginx 禁止开机自启​#Nginx配置文件Nginx配置文件包含指定指令控制的模块。指令分为简单指令和块指令一个简单指令由名称和参数组成，以空格分隔，并以分号结尾一个块指令和简单指令具有相同的结构，但不是以分号结束，而是以一个大括号包围的一堆附 加指令结束如果一个大括号内可以有其他的指令，它就被称为一个上下文，比如（events，http，server，location）指令nginx -t 不运行，仅测试配置文件nginx -c configpath 从指定路径加载配置文件nginx -t -c configpath 测试指定配置文件1234567891011121314151617main 全局设置events&#123; 工作模式，连接配置 ...&#125;http&#123; http的配置 ... upstream xxx&#123; 负载均衡配置 ... &#125; server&#123; 主机设置 ... location xxx&#123; URL匹配 ... &#125; &#125;&#125;12345678#mainuser nginx; worker进程运行的用户和组worker_processes 1; 指定Nginx开启的子进程数，多核CPU建议设置和CPU数量一样的进程数error_log xxx level; 用来定义全局错误日志文件，通常放在var中，level有 debug，info，notice， warn，error，critpid xxx; 指定进程id的存储文件位置123456789101112131415161718#events指定工作模式和以及连接上限events&#123; use epoll; worker_connections 1024;&#125;use 指定nginx工作模式 epoll 高效工作模式，linux kqueue 高效工作模式， bsd poll 标准模式 select 标准模式worker_connections 定义nginx每个进程的最大连接数 正向代理 连接数 * 进程数 反向代理 连接数 * 进程数 / 4 linux系统限制最多能同时打开65535个文件，默认上限就是65535，可解除 ulimit -n 6553512345678910111213141516#http最核心的模块，主要负责http服务器相关配置，包含server，upstream子模块include mime.types;设置文件的mime类型include xxxconfig; 包含其它配置文件，分开规划解耦default_type xxx; 设置默认类型为二进制流，文件类型未知时就会使用默认log_format 设置日志格式sendfile 设置高效文件传输模式keepalive_timeout 设置客户端连接活跃超时gzip gzip压缩123456789101112131415161718#server用来指定虚拟主机listen 80; 指定虚拟主机监听的端口server_name localhost; 指定ip地址或域名，多个域名使用空格隔开charset utf-8; 指定网页的默认编码格式error_page 500 502 /50x.html 指定错误页面access_log xxx main; 指定虚拟主机的访问日志存放路径error_log xxx main; 指定虚拟主机的错误日志存放路径root xxx; 指定这个虚拟主机的根目录index xxx; 指定默认首页123456789101112131415161718#localtion核心中的核心，以后的主要配置都在这主要功能:定位url，解析url，支持正则匹配，还能支持条件，实现动静分离语法 location [modifier] uri&#123; ... &#125;modifier 修饰符 = 使用精确匹配并且终止搜索 ~ 区分大小写的正则表达式 ~* 不区分大小写的正则表达式 ^~ 最佳匹配，不是正则匹配，通常用来匹配目录 常用指令 alias 别名，定义location的其他名字，在文件系统中能够找到，如果location指定了正则表达式，alias将会引用正则表达式中的捕获，alias替代lication中匹配的部分，没有匹配的部分将会在文件系统中搜索123456789101112#反向代理proxy_pass URL; 反向代理转发地址，默认不转发header，需要转发header则设置 proxy_set_header HOST $host;proxy_method POST; 转发的方法名proxy_hide_header Cache-Control; 指定头部不被转发 proxy_pass_header Cache-Control; 设置哪些头部转发proxy_pass_request_header on; 设置转发http请求头proxy_pass_request_body on; 设置转发请求体1234567891011121314151617#upstream负载均衡模块，通过一个简单的调度算法来实现客户ip到后端服务器的负载平衡写法 upstream myproject&#123; ip_hash; server 127.0.0.1:8000; server 127.0.0.1:8001 down; server 127.0.0.1:8002 weight=3; server 127.0.0.1:8003 backup； fair； &#125;负载均衡算法 weight 负载权重 down 当前server不参与负载均衡 backup 其它机器全down掉或满载使用此服务 ip_hash 按每个请求的hash结果分配 fair 按后端响应时间来分（第三方的）]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析基础知识]]></title>
    <url>%2Flinchao1002.github.io%2F2019%2F01%2F23%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据分析1.工具Jupyter Notebook运行命令 ：jupyter notebook快捷键：Enter : 转入编辑模式Shift-Enter : 运行本单元，选中下个单元Ctrl-Enter : 运行本单元Alt-Enter : 运行本单元，在其下插入新单元A : 在上方插入新单元B : 在下方插入新单元D,D : 删除选中的单元Tab : 代码补全或缩进M ： 单元转入markdown状态shift-Tab : 提示Ctrl-A ：全选Ctrl -Z : 复原1234567%time 运行计时,耗时长的代码%timeit (准确点)，耗时短的代码%matoplotlib 数据可视化%who 快速查看当前会话的所有变量与函数%who_ls 返回一个列表，，函数 %lsmagic 列出所有魔法命令2.numpy导入库import numpy as np创建ndarray12345678910注意： "- numpy默认ndarray的所有元素的类型是相同的", "- 如果传进来的列表中包含不同的类型，则统一为同一类型，优先级str&gt;float&gt;int" data = [1,2,3,4] nd = np.array(data) nd nd.dtype : 数据分析，分析的是什么类型的数据 nd.shape : 数据形状数据可视化包12345import matplotlib.pyplot as plt%matplotlib inlineplt.imread()plt.imshow()np.ones() ,np.zeros() ,np.full( fill_value) fill_value 填值np.reshape() 重新定义形状，给数组一个新的形状而不改变其数据np.eye() 矩阵 单元矩阵numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)在指定的间隔内返回均匀间隔的数字。np.arange( )np.random.randint(a, b, size=(c, d)) #指定生成随机数范围和生成的多维数组大小np.random.randn(d0, d1, …, dn) 标准正太分布 ,数据就是两边低中间高的数据np.random.normal(mean,stdev,size) 给出均值为mean，标准差为stdev的高斯随机数（场），当size赋值时，例如：size=100，表示返回100个高斯随机数np.random.random() 生成0到1的随机数，左闭右开astype( “uint8”) 将数据转换成uint83.ndarray的属性与基本操作4个必记参数 ： ndim维度 shape形状(各种维度的长度) size总长度 dtype 元素类型索引 ：一维与列表完全一致，多维时同理nd[1] nd[1,1]根据索引修改数据 nd[2,2] =1000切片 ： 一维与列表完全一致，多维时同理广播机制 ： 如果赋值的数据不充分的话，会自动填充变形 ： 使用reshape函数，注意参数是一个tuple级联np.concatenate() 级联的参数是一个列表，一定要加中括号或者小括号​ 维度必须相同 ，形状相符​ 级联的方向默认是shape这个tuple的第一个值所代表的维度方向​ 可通过axis 参数改变级联的方向np.hstack 水平级联 二维变一维np.vstack 垂直级联 一维变二维切分np.split np.vsplit np.hsplitndarray 聚合操作axis参数：当axis=0时，对列进行聚合操作；当axis=1时，对行进行聚合操作。求和np.sum： np.sum和np.nansum的区别 nan not a number最大最小值np.max/np.min:平均值np.mean：矩阵操作ndarray的矩阵操作广播机制：规则一：为缺失的维度补1(维度只能相差1)规则二：缺失元素用已有元素补充规则三：缺失维度的矩阵只能有一行或者一列​算数运算 np.add(a+b) / a+b矩阵积 np.dot()ndarray排序1.快速排序：np.sort()与ndarray.sort()都可以，但有区别：np.sort()不改变输入ndarray.sort()本地处理，不占用空间，但改变输2.部分排序：np.partition(a,k)有的时候我们不是对全部数据感兴趣，我们可能只对最小或最大的一部分感兴趣。当k为正时，我们想要得到最小的k个数 , 当k为负时，我们想要得到最大的k个数：4 cv2 人脸更换opencv : 计算机视觉库终端下载 : pip install opencv_pythoncv2在读的时候采用的是BGR例子 ：123456789101112sanpang = cv2.imread("./cv2_change_head/j.jpg")plt.imshow(sanpang[::,::,::-1])#CascadeClassifier:用来处理算法的类cascade = cv2.CascadeClassifier()#加载现成的算法cascade.load('./cv2_change_head/haarcascade_frontalface_default.xml')#使用人脸识别的类进行识别face = cascade.detectMultiScale(sanpang)face5. pandas的数据结构导入 import pandas as pd​ import pandas import Series ,DataFrameSeries​ Series 是一种类似与一维数组的对象，由两个部分组成：values 一组数据(ndarray 类型)index 相关的数据索引标签1.创建Series (一一对应，不能多也不能少 （索引和value值）)​ (1) 由列表或numpy数组创建 ，默认索引为 0 – N-1的整数型索引​ 例： s = Series([1,2,4])​ s= Series(np.aarray([1,2,3]), index=list(“abc”))​ (2) 由字典创建 (指定索引可多可少，多得情况补上NaN)​ s = Series (data ={“a”:10,”b”:22,”c”:33},index ={“a”,”pi”,”c”}2 .Series的索引和切片​ 可以使用中括号取单个索引（此时返回的是元素类型），或者中括号里一个列表取多 个索引（此时返回的仍然是一个Series类型）。分为显示索引和隐式索引：(1) 显式索引：- 使用index中的元素作为索引值 - 使用.loc[]（推荐） 注意，此时是闭区间​ (2) 隐式索引：- 使用整数作为索引值 - 使用.iloc[]（推荐） 注意，此时是半开区间​ 3 .Series 的基本概念1234567891011121314151617181920212223(1) 可以把Series看成一个定长的有序字典 (2)可以通过shape，size，index,values等得到series的属性 (3)可以通过head() , tail()快速查看Series对象的样式 data.head() 参数可以设置数量 data.tail() (4)当索引没有对应的值时，可能出现缺失数据显示NaN（not a number）的情况 (5) 可以使用pd.isnull()，pd.notnull()，或自带isnull(),notnull()函数检测缺失数据 #通过isnull这个函数获取boolean数据的值， 可以把它当成一个检索 会取出为True的数据，也就是空值， 对空值进行赋值 例子： ind = s.isnull() s[ind] = np.nan (6)Series对象本身及其实例都有一个name属性 s = Series(data = np.random.randint(0,150,size = 5), index = ["张三","李 四","Sara","Lisa","Michael"] ) s.name = "Python" s​4 .Series 的运算​ (1) 适用于numpy的数组运算也适用于Series​ 加减乘除 ： add subtract multiply divide​ (2) series之间的运算 ： 运算中自动对齐不同索引的数据​ 如果索引不对应，补NaN​ 要想保留所有的index,则需要使用 .add()函数二 .DataFrame​ DataFrame是一个【表格型】的数据结构，可以看做是【由Series组成的字典】（共用同一个 索引）。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。行索引：index列索引：columns值：values（numpy的二维数组）创建123456df1 = DataFrame(&#123;'Python':[99,101,120,78], "数学":[120,136,141,129], "语文":[123,114,130,117]&#125;, index = list("abcd"), columns = ["Python","数学","语文","英语"])df1行还是一对一的， 列可多可少2 .DataFrame属性​ values , columns , index , shape3 . DataFrame的索引​ (1) 对列进行索引- 通过类似字典的方式 df2[&quot;python&quot;] 两列数据： df2[[&quot;Python&quot;,&quot;php&quot;]] - 通过属性的方式 - 列切片是不行的 可以将DataFrame的列获取为一个Series。返回的Series拥有原DataFrame相同的索引，且name属性也已经设置好了，就是相应的列名。​​ (2) 对行进行索引​ #行索引不能使用中括号！！！！！！- 使用.ix[]来进行行索引 - 使用.loc[]加index来进行行索引 #对行数据进行切片, 左闭右闭 df2.loc[&quot;a&quot;:&quot;b&quot;] - 使用.iloc[]加整数来进行行索引 df2.iloc[0:3] #左闭右开的情况 #loc全部是左闭右闭 在切片的时候 iloc全部是左闭右开的 同样返回一个Series，index为原来的columns。​ (3) 对元素索引的方法- 使用列索引 - 使用行索引(iloc[3,1]相当于两个参数;iloc[[3,3]] 里面的[3,3]看做一个参数) - 使用values属性（二维numpy数组） ​ df2.loc[“a”,”Java”]#总结：进行元素索引的时候，老老实实的行是行，列是列【注意】直接用中括号时：索引表示的是列索引切片表示的是行切片4 .DataFrame之间的运算（1） DataFrame之间的运算同Series一样：在运算中自动对齐不同索引的数据如果索引不对应，则补NaN例： df1.add(df2, fill_value=0) fill_value 添值（2） Series与DataFrame之间的运算（注意axis 轴）【重要】使用Python操作符：以行为单位操作（参数必须是行），对所有行都有效。（类似于numpy中二维数组与一维数组的运算，但可能出现NaN）使用pandas操作函数：axis=0：以列为单位操作（参数必须是列），对所有列都有效。 axis=1：以行为单位操作（参数必须是行），对所有行都有效。 三 . 处理丢失数据​ numpy 中：123456789101112131415161718192021有两种丢失数据 ： None np.nan(NaN) 1.None None是Python自带的，其类型为python object。因此，None不能参与到任何计算中。 object类型的运算要比int类型的运算慢得多 计算不同数据类型求和时间 %timeit np.arange(1e5,dtype=xxx).sum() 2.np.nan(NaN) np.nan是浮点类型，能参与到计算中。但计算的结果总是NaN。 但可以使用np.nan*()函数来计算nan，此时视nan为0。pandas中None和np.nan都视作np.nan123456例子 ：df = DataFrame([[10,20,57,np.nan,None], [22,33,56,12,None], [np.nan,1,2,3,4]], index = list("abc"), columns = ["Python","Java","数学","物理","H5"])#三行五列dfPythonJAVA数学物理H5a10.02057NaNNaNb22.0335612.0NaNcNaN123.04.0pandas中None与np.nan的操作​ isnull()1总结：isnull().any() 查看数据 行或者列 是否有空值​ notnull()1总结： isnull和any 使用 notnull和all使用​ dropna() 过滤丢失数据1参数 how = "all" axis​ fillna() 填冲充丢数据12345可以选择前向填充还是后向填充前 :df3.fillna(method="ffill") #forward后 :df3.fillna(method="bfill") #back左 : df3.fillna(method="bfill",axis = 1) 右 :df3.fillna(method="ffill",axis = 1)12#扩展cond = (df3 &gt;= 10).all(axis = 1)6.pandas层次化索引​ 1.创建多层行索引​ (1) 隐式构造​ 最常见的方法是给DataFrame构造函数的index参数传递两个或者更多的数组​1234567891011121314151617181920#隐式创建s = Series(data = [1,2,3,"a"], index = [["a","a","b","b"],["期中","期末","期中","期末"]])s#二层索引df = DataFrame(data = [1,2,3,"a"], index = [["a","a","b","b"],["期中","期末","期中","期末"]], columns = ["Python"])df#三层索引df = DataFrame(data = np.random.randint(0,150,size = 8), index = [['a',"a","a","a","b","b","b","b"], ['期中',"期中","期末","期末",'期中',"期中","期末","期末"], ["一单元","二单元","一单元","二单元","一单元","二单元","一单元","二单元"]], columns = ["Python"])​ (2)显示构造pd.MultiIndex​ 使用数组123456df1 = DataFrame(data = np.random.randint(0,150,size = (8,4)), index = pd.MultiIndex.from_arrays([['a',"a","a","a","b","b","b","b"], ['期中',"期中","期末","期末",'期中',"期中","期末","期末"], ["一单元","二单元","一单元","二单元","一单元","二单元","一单元","二单元"]]), columns = ["Python","h5","php","go"])df1使用tuple1234df3 = DataFrame(np.random.randint(0,150,size = 4), index = pd.MultiIndex.from_tuples([("a",1),("a",2),("b",1),("b",2)]), columns = ["Python"])df3使用product (最简单，推荐使用)1234df4 = DataFrame(np.random.randint(0,150,size = (8,2)), index = pd.MultiIndex.from_product([list("abcd"), ["期中","期末"]]), columns = ['Python',"数学"])df4​多层列索引​ 除了行索引index ,列索引columns也能用同样的方法创建多层索引多层索引对象的索引与切片操作​ (1) 对于Series来说：直接中括号[]与使用.loc()完全一样,因此推荐使用中括号索引和括号​​ （2） DataFrame的操作​ . 可以直接使用列名称来进行索引​ . 使用行索引需要ix( ) , loc() 函数 推荐使用loc()函数注意在对行索引的时候，若一级行索引还有多个，对二级行索引会遇到问题！也就是说，无法直接对二级索引进行索引，必须让二级索引变成一级索引后才能对其进行索引！123df4["Python"]["a","期末"]df4.loc["a"].loc["期末"]["Python"]索引的堆stack( level = * )【小技巧】使用stack()的时候，level等于哪一个，哪一个就消失，出现在行里。​ unstack()​【小技巧】使用unstack()的时候，level等于哪一个，哪一个就消失，出现在列里。聚合操作【注意】需要指定axis【小技巧】和unstack()相反，聚合的时候，axis等于哪一个，哪一个就保留。所谓的聚合操作：平均数，方差，最大值，最小值……​123df4.div(10, axis = "index")df4.sum(axis = 1)df4.std() #标准差：表示的是数据的离散程度​pandas 的拼接操作​ 级联 ： pd.concat pd.append(追加，只能行追加)​ 合并 ： pd.merge ,pd.join​12pd.concat = (objs ,axis = 0,join='outer' ,join_axes=None,ignore_index=False,keys=None,levels=None,names=None,verify_integrity =False,copy= True)| 参数 | 说明 || —————- | —————————————- || objs | 参与连接的列表或字典，且列表或字典里的对象是pandas数据类型，唯一必须给定的参数 || axis=0 | 指明连接的轴向，0是纵轴，1是横轴，默认是0 || join | ‘inner’（交集）内链接，‘outer’（并集）外连接，默认是‘outer’指明轴向索引的索引是交集还是并集 || join_axis | 指明用于其他n-1条轴的索引（层次化索引，某个轴向有多个索引），不执行交并集 || keys | 与连接对象有关的值，用于形成连接轴向上的层次化索引（外层索引），可以是任意值的列表或数组、元组数据、数组列表（如果将levels设置成多级数组的话） || levels | 指定用作层次化索引各级别（内层索引）上的索引，如果设置keys的话 || names | 用于创建分层级别的名称，如果设置keys或levels的话 || verify_integrity | 检查结果对象新轴上的重复情况，如果发横则引发异常，默认False，允许重复 || ignore_index | 不保留连接轴上的索引，产生一组新索引range（total_length） |​pd.merge() 函数参数一对一，一对多，多对多| 参数 | 说明 || ———– | —————————————- || left | 参与合并的左侧DataFrame || right | 参与合并的右侧DataFrame || how | 连接方式：‘inner’（默认）；还有，‘outer’、‘left’、‘right’ || on | 用于连接的列名，必须同时存在于左右两个DataFrame对象中，如果位指定，则以left和right列名的交集作为连接键 || left_on | 左侧DataFarme中用作连接键的列 || right_on | 右侧DataFarme中用作连接键的列 || left_index | 将左侧的行索引用作其连接键 || right_index | 将右侧的行索引用作其连接键 || sort | 根据连接键对合并后的数据进行排序，默认为True。有时在处理大数据集时，禁用该选项可获得更好的性能 || suffixes | 字符串值元组，用于追加到重叠列名的末尾，默认为（‘_x’,‘_y’）.例如，左右两个DataFrame对象都有‘data’，则结果中就会出现‘data_x’，‘data_y’ || | |​ set_index() 、重新设置行索引​ query() 查询7.pandas数据处理1.删除重复元素​ 使用duplicated()函数检测重复的行，返回元素为布尔类型的Series对象，每个元素对应一行，如果该行不是第一次出现，则元素为True​ 使用drop_duplicates()函数删除重复的行映射​ 映射的含义：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定需要使用字典：map = {&apos;label1&apos;:&apos;value1&apos;, &apos;label2&apos;:&apos;value2&apos;, ... } `包含三种操作：replace()函数：替换元素最重要：map()函数：新建一列​ 由已有的列生成新的一列 map()函数中可以使用lambda函数 函数还可以传 一个回调函数 transform()和map()类似rename()函数：替换索引​异常值检测和处理​ #对数据进行过滤#std标准差，主要是看数据的稳定性​ 删除特定索引df.drop(labels,inplace = True)​ 4.排序​ (1）使用.take()函数排序，​ df. take([2,4,5] ) 根据索引取值​ （2) 可以借助np.random.permutation()函数随机排序​ (3)当DataFrame规模足够大时，直接使用np.random.randint()函数，就配合take()函数实现随机抽样数据聚合【重点】数据聚合是数据处理的最后一步，通常是要使每一个数组生成一个单一的数值。数据分类处理：分组：先把数据分为几组用函数处理：为不同组的数据应用不同的函数以转换数据合并：把不同组得到的结果合并起来数据分类处理的核心：groupby()函数 分组 groupby 之后，是聚合操作 高级数据集合(不用)​ ### 可以使用transform和apply实现相同功能12df.groupby(["color"]).transform(sum)df.groupby(["color"])[["price","weight"]].apply(sum)Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线形图(不重)123456s = Series([80,82,97,89,78,73,66], name = "数学", index = list("abcdefg"))s线性图： s.plot() 柱状图：s.plot(kind = "bar") barh(反向) 横坐标没dx ，不会支持中文DataFrame: df.plot()直方图​ 直方图，是一种特殊形状的柱状图 直方图又叫密度图​ s.hist(bins = 20)​ bins 取值 1:1-1:2​ 随机数百分比密度图 s.plot(kind = ‘kde’)#kde 内核： 专门画密度图的​ 这两种图表经常被画在一起。直方图以规格化形式给出（以便给出面元化密度），然后再在其上绘制核密度估计。接下来来看一个由两个不同的标准正态分布组成的的双峰分布np.random.normal()正太分布函数直方图hist，函数中必须添加属性normed = True8. scipy123scipy.fftpack模块用来计算快速傅里叶变换 速度比传统傅里叶变换更快，是对之前算法的改进 图片是二维数据，注意使用fftpack的二维转变方法使用傅里叶变换。把数据变成信号数据 fftpack.fft2()​ 反向傅里叶变换 fftpack.ifft2()1np.real() plt.figure() 尺寸数值积分，求解圆周率1使用scipy.integrate进行积分，调用quad()方法scipy文件输入/输出​ from scipy import io​ 随机生成数组，使用scipy中的io.savemat()保存 文件格式是.mat，标准的二进制文件123io.savemat("./1811.mat", &#123;"nd":nd&#125;)io.loadmat("./1811.mat")["nd"] 读取数据读写图片使用scipy中 misc.imread()/imsave()​ misc.imrotate ( ) 旋转图片​ .resize() , imfilter()图片处理​ ndimage 处理图片的包​ 使用scipy.misc.face(gray=True)获取图片，使用ndimage移动坐标、旋转图片、切割图片、 缩放图片123ndimage.shift() 移动坐标ndimage.rotate() 旋转图片ndimage.zoom() 缩放图片图片进行过滤添加噪声，对噪声图片使用ndimage中的高斯滤波、中值滤波、signal中维纳滤波进行处理使图片变清楚9.matplotlibMatplotlib基础知识： Matplotlib中的基本图表包括的元素​ x轴和y轴​ 水平和垂直的轴线​ x轴和y轴刻度​ 刻度标示坐标轴的分隔，包括最小刻度和最大刻度​ x轴和y轴刻度标签​ 表示特定坐标轴的值​ 绘图区域​ 实际绘图的区域(1) plt.plot(x,y,format_string,**kwargs)​ x轴数据，y轴数据，format_string控制曲线的格式字串​ format_string 由颜色字符，风格字符，和标记字符​ **kwargs:第二组或更多，(x,y,format_string)​123456789color:控制颜色，color=’green’ linestyle:线条风格，linestyle=’dashed’ marker:标记风格，marker = ‘o’ markerfacecolor:标记颜色，markerfacecolor = ‘blue’ markersize:标记尺寸，markersize = ‘20’plt.grid(True) #设置网格线lw代表linewidth，线的粗细alpha表示线的明暗程度plt.title() #标题12345678910111213fontsize设置字体大小，默认12，可选参数 ['xx-small', 'x-small', 'small', 'medium', 'large','x-large', 'xx-large']fontweight设置字体粗细，可选参数 ['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']fontstyle设置字体类型，可选参数[ 'normal' | 'italic' | 'oblique' ]，italic斜体，oblique倾斜verticalalignment设置水平对齐方式 ，可选参数 ： 'center' , 'top' , 'bottom' ,'baseline' horizontalalignment设置垂直对齐方式，可选参数：left,right,centerrotation(旋转角度)可选参数为:vertical,horizontal 也可以为数字alpha透明度，参数值0至1之间backgroundcolor标题背景颜色bbox给标题增加外框 ，常用参数如下： boxstyle方框外形 facecolor(简写fc)背景颜色 edgecolor(简写ec)边框线条颜色 edgewidth边框线条大小plt.xlabel()/ylabel() #设置轴标签 参数：rotation 旋转度数plt.legend(loc=’upper left’) #设置legend显示，并指定位置1234567891011121314| 字符串 | 数值 | 字符串 | 数值 || :-------------: |:-----------:| :-----:| :-----:|| best | 0 | center left | 6 || upper right | 1 | center right | 7 || upper left | 2 | lower center | 8 || lower left | 3 | upper center | 9 || lower right | 4 | center | 10 || right | 5 | ncol控制图例中有几列 mode = （可拉伸的） bbox_to_anchor (锚点) 例子： bbox_to_anchor= [o,2,1,0.1] 前两个值是坐标点，第三个值宽度，最后一个是距离y轴的距离 facecolor 背景颜色plt.show() #显示图像设置坐标轴范围除了plt.axis方法，还可以通过xlim，ylim方法设置坐标轴范围12添加子视图axes1 = figure.add_subplot(1,3,1) #表示一行三列第一个​ 不同程度的破折线​ dashes =[ ] #注意偶数​（2）保存图片​ plt.savefig()（3）三种设置方式​ 1.向方法传入关键字参数​ 2.使用setp()方法​ 3 .对实例使用一系列的setter方法(4) x,y轴坐标刻度123locs, labels = plt.xticks() # 不传入任何参数，xticks()会返回当前刻度的位置和标签Π，α，β，----》 ["$\pi$"]2D图形(1) 直方图]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>numpy</tag>
        <tag>matoplotlib可视化</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目部署上线指南]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F11%2F22%2F%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>nginx</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker中Mongodb用户管理]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F10%2F18%2Fdocker%E4%B8%ADMongoD%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[0.前言mongodb作为时下最为热门的数据库，那么其安全验证也是必不可少的，否则一个没有验证的数据库暴露出去，任何人可随意操作，这将是非常危险的。本篇就mongodb的用户操作及用户验证来作探讨。1. 安装自docker面世以来，后端部署和环境搭建已逐渐步入容器化时代，作为一名有追求有作为的程序员，你有必要对前沿的技术有所了解和探讨。个人推荐使用docker搭建你的mongodb，操作也十分简单。首先，获取docker官方的mongodb镜像，也可以是第三方源的镜像1docker pull mongo效果图如下:其次，启动你的mongo镜像，如下:1docker run --name mymongo -p 27017:27017 -v /home/mongodb/data:/data/db -d mongo简单解释下：docker run 命令用于启动一个容器， –name mymongo 指定容器的名称为mymongo-p 27017:27017，将容器内27017端口映射到服务器27017端口-v /home/mongodb/data:/data/db，指定数据存储目录/home/mongodb/data映射到容器内的/data/db存储目录-d 守护进程运行mongo 指定运行的镜像那么，如何开启验证呢？也简单，只需要加上–auth即可:1docker run --name mymongo -p 27017:27017 -v /home/mongodb/data:/data/db -d mongo --auth至此，一个mongo容器就可以跑起来了，还有更多可操作的地方，不在主题范围内，这里不做详细阐述。要注意的是，首次启动，或还没有设置用户验证之前，请不要开启验证，后面会讲到。2. 创建db管理账户在创建用户之前，我们来看看db用户具体可以有哪些权限：mongodb用户权限列表:12345678910111213141516171819Read：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profileuserAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。root：只在admin数据库中可用。超级账号，超级权限mongodb有一个用户管理机制，简单描述为，有一个管理用户组，这个组的用户是专门为管理普通用户而设的，暂且称之为管理员。管理员通常没有数据库的读写权限，只有操作用户的权限, 因此我们只需要赋予管理员userAdminAnyDatabase角色即可另外管理员账户必须在admin数据库下创建，3.0版本后没有admin数据库，但我们可以手动use一个1use admin下面我们来创建一个管理账户首先，要进入mongo，以我本地数据库为例如图：如果数据库使用docker搭建的，则需要进入你的mongo容器内去操作。比如，以我的服务器mongo镜像为例：切换到admin数据库，创建管理员进入mongo之后，那么意味着我们可以操作db了。需要明白的一点是，管理员需要在admin数据库下创建，所以我们得进入admin数据库使用use命令，即可进入某个数据库，如下:1use admin切换到admin数据库后，我们可以查看db的用户列表，此时用户列表是空的，因为我们还没有创建db用户12db.system.users.find()# 此时列表为空接着，开始创建你的管理员账户，比如，创建一个用户名为super, 密码为superpwd的管理员账户:1234db.createUser(&#123; user: ‘super’, pwd: ‘superpwd’, roles: [ &#123; role: "userAdminAnyDatabase", db: "admin" &#125; ] &#125;);成功则会提示Successfully注意：这里使用createUser()方法来创建，addUser()方法已经被废弃管理员授权创建管理员后，需要给管理员授权，否则无权限操作用户授权也十分简单，如下：1db.auth('super','superpwd')如果结果返回1，则表示授权成功，返回0则表示失败至此，管理员创建完成。下面是完整流程：3. 使用管理员账户创建普通用户普通用户由管理员创建，并授权。通常需要指定某个数据库来操作。先看需求比如，现在我需要创建一个blog数据库，并且给这个数据库添加一个用户，用户名为develop,密码为developpwd，只有这个用户可以操作这个blog数据库。管理员账户登录需要明白一点的是，普通用户需要由管理员创建并授权，所以，我们首先做的就是用管理员账户登录数据库提示：在管理员账户创建完成后，我们需要重新启动数据库，并开启验证以docker为例:12# 重新启动，开启验证docker run --name mymongo -p 27017:27017 -v /home/mongodb/data:/data/db -d mongo --auth重新启动之后，我们就可以用管理员账户进入mongo，如下:12# 指定用户进入mongo可使用: mongo admin -u 用户名 -p 密码mongo admin -u super -p superpwd进入之后，我们就可以做用户操作了创建数据库，并创建用户进入mongo之后，首先切换到blog数据库12use blog# 没有则会自动创建紧接着，可以创建develop用户了123456db.createUser(&#123; user: "develop", pwd: "developpwd", roles: [ &#123; role: "readWrite", db: "blog" &#125; ] &#125;)# 指定可访问blog数据库，并给予readWrite(读写)权限再接着就是给develop用户授权了1db.auth('develop','developpwd')至此，普通用户develop创建完成。这时，我们就可以使用develop用户连接blog数据库了，如下;1mongo mongodb://develop:developpwd@localhost:27017/blog至此，用户验证处理完成。4. 一些用户操作命令提示： 需要使用管理员账户来操作创建用户1234567db.createUser(&#123; user:用户名, pwd:密码, roles:[ &#123; role:权限类型, db:可访问的db&#125; ]&#125;)查看用户列表1db.system.users.find()查看某个用户信息1db.runCommand(&#123;usersInfo:用户名&#125;)修改用户信息1234567db.runCommand( &#123; updateUser:用户名, pwd:密码, customData:&#123;title:"xxx"……&#125; &#125;)修改用户密码1db.changeUserPassword(‘user’,’pwd’);删除用户1db.system.users.remove(&#123;user:”username”&#125;);]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker简易上手指南]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F10%2F15%2F2019-2-23%20Docker%E7%AE%80%E6%98%93%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97%20172306%2F</url>
    <content type="text"><![CDATA[Docker简介软件开发中最为麻烦的事情可能就是配置环境了。由于用户使用的操作系统具有多样性，即便使用跨平台的开发语言（如Java和Python）都不能保证代码能够在各种平台下都可以正常的运转，而且可能在不同的环境下我们的软件需要依赖的其他软件包也是不一样的。那么问题来了，我们再安装软件的时候可不可以把软件运行的环境一并安装？也就是说在安装软件的时候，我们是不是可以把原始环境一模一样地复制过来呢？虚拟机（virtual machine）就是带环境安装的一种解决方案，它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里面运行Linux系统，在macOS上运行Windows，而应用程序对此毫无感知。使用过虚拟机的人都知道，虚拟机用起来跟真实系统一模一样，而对于虚拟机的宿主系统来说，虚拟机就是一个普通文件，不需要了就删掉，对宿主系统或者其他的程序并没有影响。但是虚拟机通常会占用较多的系统资源，启动和关闭也非常的缓慢，总之用户体验没有想象中的那么好。Docker属于对Linux容器技术的一种封装，它提供了简单易用的容器使用接口，是目前最流行的 Linux 容器解决方案。Docker将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker就再也不用担心环境问题了。目前，Docker主要用于几下几个方面：提供一次性的环境。提供弹性的云服务（利用Docker很容易实现扩容和收缩）。实践微服务架构（隔离真实环境在容器中运行多个服务）。CentOS下的安装和使用下面的讲解以CentOS为例，使用Ubuntu、macOS或Windows的用户可以通过点击链接了解这些平台下如何安装和使用Docker。确定操作系统内核版本（CentOS 7要求64位，内核版本3.10+；CentOS 6要求64位，内核版本2.6+）。1uname -r在CentOS下使用yum安装Docker并启动。12yum -y install docker-iosystemctl start docker检视Docker的信息和版本。12docker versiondocker info运行Hello-World项目来测试Docker。第一次运行时由于本地没有hello-world的镜像因此需要联网进行下载。1docker run hello-world也可以先用下面的命令下载镜像，然后再来运行。 1docker pull &lt;name&gt;运行镜像文件。12docker run &lt;image-id&gt;docker run -p &lt;port1&gt;:&lt;port2&gt; &lt;name&gt;查看镜像文件。12docker image lsdocker images删除镜像文件。1docker rmi &lt;name&gt;查看正在运行容器。1docker ps停止运行的容器。12docker stop &lt;container-id&gt;docker stop &lt;name&gt;对于那些不会自动终止的容器，就可以用下面的方式来停止。1docker container kill &lt;container-id&gt;在Ubuntu（内核版本3.10+）下面安装和启动Docker，可以按照如下的步骤进行。123apt updateapt install docker-ceservice docker start在有必要的情况下，可以更换Ubuntu软件下载源来提升下载速度，具体的做法请参照https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/。安装Docker后，由于直接访问dockerhub下载镜像会非常缓慢，建议更换国内镜像，可以通过修改/etc/docker/daemon.js文件来做到。123456&#123; "registry-mirrors": [ "http://hub-mirror.c.163.com", "https://registry.docker-cn.com" ]&#125;Docker实战安装NginxDocker的使用肯定不止上面这点东西，但是有了这些知识之后，我们已经可以开始感受Docker的强大之处。下面我们就基于Docker来搭建HTTP服务器（Nginx）环境。1docker container run -d -p 80:80 --rm --name mynginx nginx说明：上面的参数-d表示容器在后台运行；-p是用来映射容器的端口到宿主机的端口；--rm表示容器停止后自动删除容器，例如通过docker container stop mynginx以后，容器就没有了；--name是自定义容器的名字。如果需要将自己的页面部署到Nginx上，可以使用容器的拷贝命令将当前文件夹下所有的文件和文件夹拷贝到容器的指定目录中。当然也可以从容器中拷贝文件到我们指定的路径下。1docker container cp ./index.html mynginx:/usr/local/nginx/html如果不愿意拷贝文件也可以将文件夹映射到Nginx保存页面文件的目录。1docker container run -d -p 80:80 --rm --name mynginx --volume "$PWD/html":/usr/share/nginx/html nginx安装MySQL下载MySQL镜像。123docker search mysqldocker pull mysql:5.7docker images启动容器运行MySQL。1docker run --name mysql-docker -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7在使用MySQL 8.x时可能会遇到“error 2059: Authentication plugin ‘caching_sha2_password’ cannot be loaded”的问题，这是因为MySQL 8.x默认使用了名为“caching_sha2_password”的机制对用户口令进行了更好的保护，但是如果客户端没有更新有可能无法基于这种方式进行身份验证，可以按照下面的方式加以解决。1docker exec -it mysql8-docker /bin/bash进入容器的交互式Shell之后，可以首先利用MySQL的客户端工具连接MySQL服务器。12345678910mysql -u root -pEnter password:Your MySQL connection id is 16Server version: 8.0.12 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt;接下来通过SQL来修改用户口令就可以了。1alter user 'root'@'%' identified with mysql_native_password by '123456' password expire never;当然，如果愿意你也可以查看一下用户表检查是否修改成功。123456789use mysql;select user, host, plugin, authentication_string from user where user='root';+------+-----------+-----------------------+-------------------------------------------+| user | host | plugin | authentication_string |+------+-----------+-----------------------+-------------------------------------------+| root | % | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 || root | localhost | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+------+-----------+-----------------------+-------------------------------------------+2 rows in set (0.00 sec)接下来就已经可以访问你的MySQL服务器啦，当然远程连接的时候不要忘了在防火墙上开启对应的端口。补充：为什么需要创建docker用户组？Docker守候进程绑定的是一个unix socket，而不是TCP端口。这个套接字默认的属主是root，其他是用户可以使用sudo命令来访问这个套接字文件。因为这个原因，docker服务进程都是以root帐号的身份运行的。为了避免每次运行docker命令的时候都需要输入sudo，可以创建一个docker用户组，并把相应的用户添加到这个分组里面。当docker进程启动的时候，会设置该套接字可以被docker这个分组的用户读写。这样只要是在docker这个组里面的用户就可以直接执行docker命令了。警告：该dockergroup等同于root帐号，具体的详情可以参考这篇文章：Docker Daemon Attack Surface.服务器环境：centos7，docker1.12.61.使用有sudo权限的帐号登录到服务器系统，如：jayzhen用户2.新建用户组docker之前，查看用户组中有没有docker组1sudo cat /etc/group | grep docker3.创建docker分组，并将相应的用户添加到这个分组里面。1234sudo groupadd -g 999 docker #-g 999为组ID，也可以不指定sudo usermod -aG dockerroot jayzhensudo usermod -aG docker jayzhen4.检查一下创建是否有效cat /etc/group5.退出当前用户登陆状态，然后重新登录，以便让权限生效,或重启docker-daemon1sudo systemctl restart docker6.确认你可以直接运行docker命令，执行docker命令1docker info如果提示get ……dial unix /var/run/docker.sock权限不够，则修改/var/run/docker.sock权限1sudo chmod a+rw /var/run/docker.sock]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7上安装docker]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F09%2F18%2FCentos7%E4%B8%8A%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[Centos7上安装dockerDocker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。##一、安装docker1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。通过 uname -r 命令查看你当前的内核版本$ uname -r2、使用 root 权限登录 Centos。确保 yum 包更新到最新。$ sudo yum update3、卸载旧版本(如果安装过旧版本的话)$ sudo yum remove docker docker-common docker-selinux docker-engine4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的$ sudo yum install -y yum-utils device-mapper-persistent-data lvm25、设置yum源$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo6、可以查看所有仓库中所有docker版本，并选择特定版本安装$ yum list docker-ce --showduplicates | sort -r7、安装docker$ sudo yum install docker-ce #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0$ sudo yum install &lt;FQPN&gt; # 例如：sudo yum install docker-ce-17.12.0.ce8、启动并加入开机启动$ sudo systemctl start docker$ sudo systemctl enable docker9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)$ docker version]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo网站时间修改]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F08%2F23%2Fhexo%E7%BD%91%E7%AB%99%E6%97%B6%E9%97%B4%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[HEXO 网站时间修改网站建立时间​ 这个时间将在站点的底部显示，例如 © 2017 - 2018。 编辑 主题配置文件，_config.yml搜索 since​ 修改参数即可网站已运行时间编辑主题源文件./themes/layout/_parrials/footer.swing找到以下代码区块1234&#123;% if theme.footer.theme.enable %&#125;/* ... */&#123;% endif %&#125;HLJS | COPY在 &lt;/div&gt; 之前添加123&lt;span&gt; | &lt;/span&gt;&lt;span id="showDays"&gt;&lt;/span&gt;LANG-HTML | COPY在该文件末尾处添加12345678910111213141516171819202122232425&lt;script&gt; var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var birthDay = Date.UTC(2016,07,30,00,00,00); // 这里设置建站时间 setInterval(function() &#123; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = now - birthDay; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById('showDays').innerHTML="本站已运行 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒"; &#125;, 1000);&lt;/script&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDb数据库基本知识]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F08%2F23%2FMongoDB%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[MongoDb 学习：http://www.runoob.com/mongodb/mongodb-tutorial.htmlMongoDB特点:高性能、易部署、易使用，存储数据非常方便。主要功能特性有：面向集合存储，易存储对象类型的数据。模式自由。支持动态查询。支持完全索引，包含内部对象。支持查询。支持复制和故障恢复。使用高效的二进制数据存储，包括大型对象（如视频等）。自动处理碎片，以支持云计算层次的扩展性支持Python，PHP，Ruby，Java，C，C#，Javascript，Perl及C++语言的驱动程序，社区中也提供了对Erlang及.NET等平台的驱动程序。文件存储格式为BSON（一种JSON的扩展）。可通过网络访问。功能:面向集合的存储：适合存储对象及JSON形式的数据。动态查询：Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。完整的索引支持：包括文档内嵌对象及数组。Mongo的查询优化器会分析查询表达式，并生成一个高效的查询计划。查询监视：Mongo包含一个监视工具用于分析数据库操作的性能。复制及自动故障转移：Mongo数据库支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器。适用场合:网站数据：Mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。缓存：由于性能很高，Mongo也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo搭建的持久化缓存层可以避免下层的数据源 过载。大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。高伸缩性的场景：Mongo非常适合由数十或数百台服务器组成的数据库。Mongo的路线图中已经包含对MapReduce引擎的内置支持。用于对象及JSON数据的存储：Mongo的BSON数据格式非常适合文档化格式的存储及查询。MongoDB要注意的问题因为MongoDB是全索引的，所以它直接把索引放在内存中，因此最多支持2.5G的数据。如果是64位的会更多。因为没有恢复机制，因此要做好数据备份因为默认监听地址是127.0.0.1，因此要进行身份验证，否则不够安全；如果是自己使用，建议配置成localhost主机名通过GetLastError确保变更。（这个不懂，实际中没用过）MongoDB结构介绍MongoDB中存储的对象时BSON，是一种类似JSON的二进制文件，它是由许多的键值对组成。如下所示12345678910&#123; "name" : "huangz", "age" : 20, "sex" : "male" &#125; &#123; "name" : "jack", "class" : 3, "grade" : 3 &#125;而数据库的整体结构组成如下：键值对–》文档–》集合–》数据库MongoDB的文件单个大小不超过4M，但是新版本后可提升到16MMongoDB中的key命名规则如下：“\0”不能使用带有”.”号，”_”号和”$”号前缀的Key被保留大小写有区别，Age不同于age同一个文档不能有相同的Key除了上面几条规则外，其他所有UTF-8字符都可以使用常用命令：1 #进入数据库1use admin2 #增加或修改密码123db.addUser('xingoo','123')db.addUser("xingoo","123",true) 参数分别为 用户名、密码、是否只读3 #查看用户列表1db.system.users.find()4 #用户认证1db.auth('xingoo','123')5 #删除用户1db.removeUser('xingoo')6 #查看所有用户1show users7 #查看所有数据库1show dbs8 #查看所有的collection集合1show collections9 #查看各个collection的状态1db.printCollectionStats()10 #查看主从复制状态1db.printReplicationInfo()11 #修复数据库1db.repairDatabase()12 #设置profiling,0:off 1:slow 2 all1db.setProfilingLevel(1)13 #查看profiling1show profiling14 #拷贝数据库123db.copyDatabase('xingootest','xingootest1')db.copyDatabase("xingootest","temp","127.0.0.1")15 #删除集合collection1db.xingootest.drop()16 #删除当前数据库1db.dropDatabase()MongoDB增删改命令1 #存储嵌套的对象1db.foo.save(&#123;'name':xingoo,'age':25,'address':&#123;'city':'changchun','Province':'Jilin'&#125;&#125;)2 #存储数组对象1db.foo.save(&#123;'name':xingoo,'age':25,'address':['Jilin Province','Liaoning Province']&#125;)3 #根据query条件修改，如果不存在则插入，允许修改多条记录1db.foo.update(&#123;'age':'25'&#125;,&#123;'$set':&#123;'name':'xingoo'&#125;&#125;,upsert=true,multi=true)4 #删除yy=5的记录1db.foo.remove(&#123;'name':'xingoo'&#125;)5 #删除所有的记录1db.foo.remove()索引1 #增加索引:1 asc -1 desc1db.foo.ensureIndex(&#123;firstname:1,lastname:-1&#125;,&#123;unieap:true&#125;)2 #索引子对象(不懂)1db.foo.ensureIndex(&#123;'Al.Em':!&#125;)3 #查看索引信息123db.foo.getIndexes()db.foo.getIndexKeys()4 #根据索引名删除索引(不懂)1db.foo.dropIndex('Al.Em_1')查询条件操作符12345678910 1 $gt ---- &gt; 2 $lt ---- &lt; 3 $gte ---- &gt;= 4 $lte ---- &lt;= 5 $ne ---- != 、&lt;&gt; 6 $in ---- in 7 $nin ---- not in 8 $all ---- all 9 $or ---- or10 $not ---- 反匹配1 #查询所有记录1db.foo.find() ---- select * from foo2 #查询某列非重复的记录1db.foo.distinct("xingoo") ---- select distinct name from foo3 #查询age = 22 的记录1db.foo.find(&#123;"age":22&#125;) ---- select * from foo where age = 224 #查询age &gt; 22 的记录1db.foo.find(&#123;age:&#123;$gt:22&#125;&#125;) ---- select * from foo where age &gt; 225 #查询age &lt; 22 的记录1db.foo.find(&#123;age:&#123;$lt:22&#125;&#125;) ---- select * from foo where age &lt; 226 #查询age &lt;= 25的记录1db.foo.find(&#123;age:&#123;$lte:25&#125;&#125;)7 #查询age &gt;= 23 并且 age &lt;=26的记录1db.foo.find(&#123;age:&#123;lte:26&#125;&#125;)8 #查询name中包含xingoo的数据1db.foo.find(&#123;name:/xingoo/&#125;) ---- select * from foo where name like '%xingoo%'9 #查询name中以xingoo开头的数据1db.foo.find(&#123;name:/^xingoo/&#125;) ---- select * from foo where name like 'xingoo%'10 #查询指定列name、age的数据1db.foo.find(&#123;&#125;,&#123;name:1,age:1&#125;) ---- select name,age from foo11 #查询制定列name、age数据，并且age &gt; 221db.foo.find(&#123;age:&#123;$gt:22&#125;&#125;,&#123;name:1,age:1&#125;) ---- select name,age from foo where age &gt;2212 #按照年龄排序12升序：db.foo.find().sort(&#123;age:1&#125;) 降序：db.foo.find().sort(&#123;age:-1&#125;)13 #查询name=xingoo.age=25的数据1db.foo.find(&#123;name:'xingoo',age:22&#125;) ---- select * from foo where name='xingoo' and age ='25'14#查询前5条数据1db.foo.find().limit(5) ---- select top 5 * from foo15 #查询10条以后的数据1db.foo.find().skip(10) ---- select * from foo where id not in (select top 10 * from foo);16 #查询在5-10之间的数据1db.foo.find().limit(10).skip(5)17 #or与查询1db.foo.find(&#123;$or:[&#123;age:22&#125;,&#123;age:25&#125;]&#125;) ---- select * from foo where age=22 or age =2518 #查询第一条数据1db.foo.findOne() 、db.foo.find().limit(1)---- select top 1 * from foo19 #查询某个结果集的记录条数1db.foo.find(&#123;age:&#123;$gte:25&#125;&#125;).count() ---- select count(*) from foo where age &gt;= 2020 #按照某列进行排序(不懂)1db.foo.find(&#123;sex:&#123;$exists:true&#125;&#125;).count() ---- select count(sex) from foo21 #查询age取模10等于0的数据1db.foo.find('this.age % 10 == 0')、db.foo.find(&#123;age:&#123;$mod:[10,0]&#125;&#125;)22 #匹配所有1db.foo.find(&#123;age:&#123;$all:[22,25]&#125;&#125;)23 #查询不匹配name=X*带头的记录1db.foo.find(&#123;name:&#123;$not:/^X.*/&#125;&#125;)24 #排除返回age字段1db.foo.find(&#123;name:'xingoo'&#125;,&#123;age:0&#125;)25 #判断字段是否存在1db.foo.find(&#123;name:&#123;$exists:true&#125;&#125;)管理1 #查看collection数据大小1db.xingootest.dataSize()2 #查看collection状态1db.xingootest.stats()3 #查询所有索引的大小1db.xingootest.totalIndexSize()原文：https://blog.csdn.net/qq_35553341/article/details/77096254]]></content>
      <categories>
        <category>Mongodb</category>
      </categories>
      <tags>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django配置celery执行异步任务和定时任务]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F07%2F22%2FDjango%E9%85%8D%E7%BD%AEcelery%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Django配置celery执行异步任务和定时任务实例学习：https://github.com/search?q=django+celery官方文档：http://www.celeryproject.org/Celery4.1中文文档-用户指南(User Guide)：https://blog.csdn.net/weixin_40475396/article/details/80439781celery是一个基于python开发的简单、灵活且可靠的分布式任务队列框架，支持使用任务队列的方式在分布式的机器/进程/线程上执行任务调度。采用典型的生产者-消费者模型，主要由三部分组成：消息队列broker：broker实际上就是一个MQ队列服务，可以使用redis、rabbitmq等作为broker处理任务的消费者workers：broker通知worker队列中有任务，worker去队列中取出任务执行，每一个worker就是一个进程存储结果的backend：执行结果存储在backend，默认也会存储在broker使用的MQ队列服务中，也可以单独配置用何种服务做backend异步任务我的异步使用场景为项目上线：前端web上有个上线按钮，点击按钮后发请求给后端，后端执行上线过程要5分钟，后端在接收到请求后把任务放入队列异步执行，同时马上返回给前端一个任务执行中的结果。若果没有异步执行会怎么样呢？同步的情况就是执行过程中前端一直在等后端返回结果，页面转呀转的就转超时了。异步任务配置1.安装rabbitmq，这里我们使用rabbitmq作为broker，安装完成后默认启动了，也不需要其他任何配置12# apt-get install rabbitmq-server复制代码2.安装celery12# pip3 install celery复制代码3.celery用在django项目中，django项目目录结构(简化)如下1234567891011121314151617181920website/|-- deploy| |-- admin.py| |-- apps.py| |-- __init__.py| |-- models.py| |-- tasks.py| |-- tests.py| |-- urls.py| `-- views.py|-- manage.py|-- README`-- website |-- celery.py |-- __init__.py |-- settings.py |-- urls.py `-- wsgi.py复制代码4.创建website/celery.py主文件12345678910111213141516171819202122232425from __future__ import absolute_import, unicode_literalsimport osfrom celery import Celery, platforms# set the default Django settings module for the 'celery' program.os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'website.settings')app = Celery('website')# Using a string here means the worker don't have to serialize# the configuration object to child processes.# - namespace='CELERY' means all celery-related configuration keys# should have a `CELERY_` prefix.app.config_from_object('django.conf:settings', namespace='CELERY')# Load task modules from all registered Django app configs.app.autodiscover_tasks()# 允许root 用户运行celeryplatforms.C_FORCE_ROOT = True@app.task(bind=True)def debug_task(self): print('Request: &#123;0!r&#125;'.format(self.request))复制代码5.在website/__init__.py文件中增加如下内容，确保django启动的时候这个app能够被加载到12345678from __future__ import absolute_import# This will make sure the app is always imported when# Django starts so that shared_task will use this app.from .celery import app as celery_app__all__ = ['celery_app']复制代码6.各应用创建tasks.py文件，这里为deploy/tasks.py1234567from __future__ import absolute_importfrom celery import shared_task@shared_taskdef add(x, y): return x + y复制代码注意tasks.py必须建在各app的根目录下，且只能叫tasks.py，不能随意命名7.views.py中引用使用这个tasks异步处理12345from deploy.tasks import adddef post(request): result = add.delay(2, 3)复制代码使用函数名.delay()即可使函数异步执行可以通过result.ready()来判断任务是否完成处理如果任务抛出一个异常，使用result.get(timeout=1)可以重新抛出异常如果任务抛出一个异常，使用result.traceback可以获取原始的回溯信息8.启动celery12# celery -A website worker -l info复制代码9.这样在调用post这个方法时，里边的add就可以异步处理了定时任务定时任务的使用场景就很普遍了，比如我需要定时发送报告给老板~定时任务配置1.website/celery.py文件添加如下配置以支持定时任务crontab12345678910111213141516from celery.schedules import crontabapp.conf.update( CELERYBEAT_SCHEDULE = &#123; 'sum-task': &#123; 'task': 'deploy.tasks.add', 'schedule': timedelta(seconds=20), 'args': (5, 6) &#125; 'send-report': &#123; 'task': 'deploy.tasks.report', 'schedule': crontab(hour=4, minute=30, day_of_week=1), &#125; &#125;)复制代码定义了两个task：名字为’sum-task’的task，每20秒执行一次add函数，并传了两个参数5和6名字为’send-report’的task，每周一早上4：30执行report函数timedelta是datetime中的一个对象，需要from datetime import timedelta引入，有如下几个参数days：天seconds：秒microseconds：微妙milliseconds：毫秒minutes：分hours：小时crontab的参数有：month_of_year：月份day_of_month：日期day_of_week：周hour：小时minute：分钟2.deploy/tasks.py文件添加report方法：1234@shared_taskdef report(): return 5复制代码3.启动celery beat，celery启动了一个beat进程一直在不断的判断是否有任务需要执行12# celery -A website beat -l info复制代码Tips1.如果你同时使用了异步任务和计划任务，有一种更简单的启动方式celery -A website worker -b -l info，可同时启动worker和beat 2.如果使用的不是rabbitmq做队列那么需要在主配置文件中website/celery.py配置broker和backend，如下：12345# redis做MQ配置app = Celery('website', backend='redis', broker='redis://localhost')# rabbitmq做MQ配置app = Celery('website', backend='amqp', broker='amqp://admin:admin@localhost')复制代码3.celery不能用root用户启动的话需要在主配置文件中添加platforms.C_FORCE_ROOT = True4.celery在长时间运行后可能出现内存泄漏，需要添加配置CELERYD_MAX_TASKS_PER_CHILD = 10，表示每个worker执行了多少个任务就死掉]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>celery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 下通过nginx+uwsgi部署django应用]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F06%2F21%2Fcentos7%20%E4%B8%8B%E9%80%9A%E8%BF%87nginx%2Buwsgi%E9%83%A8%E7%BD%B2django%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[centos学习：http://www.runoob.com/linux/linux-install.html1. 安装python3.61234567891011121314151. 获取wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgztar -xzvf Python-3.6.2.tgz -C /tmpcd /tmp/Python-3.6.2/2. 把Python3.6安装到 /usr/local 目录./configure --prefix=/usr/localmakemake altinstall3. 更改/usr/bin/python链接ln -s /usr/local/bin/python3.6 /usr/bin/python32. maridb12345678910111213141516171819202122232425262728293031323334353637381. 安装 sudo yum install mariadb-server2. 启动， 重启 sudo systemctl start mariadb sudo systemctl restart mariadb3. 设置bind-ip vim /etc/my.cnf 在 [mysqld]: 下面加一行 bind-address = 0.0.0.04. 设置外部ip可以访问 先进入mysql才能运行下面命令: mysql 直接进入就行 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; FLUSH PRIVILEGES5. 设置阿里云的对外端口 视频中有讲解这部分6. 安装mysqlclient出问题 centos 7： yum install python-devel mariadb-devel -y ubuntu： sudo apt-get install libmysqlclient-dev 然后： pip install mysqlclient3. 安装nginx1https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-74. 安装virtualenvwrapper12yum install python-setuptools python-develpip install virtualenvwrapper12&gt; 编辑.bashrc文件&gt;12export WORKON_HOME=$HOME/.virtualenvssource /usr/local/bin/virtualenvwrapper.sh1234567891011&gt; 重新加载.bashrc文件&gt; source ~/.bashrc&gt; &gt; 新建虚拟环境&gt; mkvirtualenv mxonline&gt; &gt; 进入虚拟环境 &gt; workon mxonline&gt; &gt; 安装pip包&gt;123456我们可以通过 pip freeze &gt; requirements.txt 将本地的虚拟环境安装包相信信息导出来然后将requirements.txt文件上传到服务器之后运行：pip install -r requirements.txt安装依赖包5. 安装uwsgi1pip install uwsgi6. 测试uwsgi1uwsgi --http :8000 --module MxOnline.wsgi7. 配置nginx1234567891011121314151617181920212223242526272829303132333435新建uc_nginx.conf# the upstream component nginx needs to connect toupstream django &#123;# server unix:///path/to/your/mysite/mysite.sock; # for a file socketserver 127.0.0.1:8000; # for a web port socket (we'll use this first)&#125;# configuration of the serverserver &#123;# the port your site will be served onlisten 80;# the domain name it will serve forserver_name 你的ip地址 ; # substitute your machine's IP address or FQDNcharset utf-8;# max upload sizeclient_max_body_size 75M; # adjust to taste# Django medialocation /media &#123; alias 你的目录/Mxonline/media; # 指向django的media目录&#125;location /static &#123; alias 你的目录/Mxonline/static; # 指向django的static目录&#125;# Finally, send all non-media requests to the Django server.location / &#123; uwsgi_pass django; include uwsgi_params; # the uwsgi_params file you installed&#125;&#125;8. 将该配置文件加入到nginx的启动配置文件中1sudo ln -s 你的目录/Mxonline/conf/nginx/uc_nginx.conf /etc/nginx/conf.d/8. 拉取所有需要的static file 到同一个目录12345在django的setting文件中，添加下面一行内容： STATIC_ROOT = os.path.join(BASE_DIR, "static/")运行命令 python manage.py collectstatic9. 运行nginx1sudo /usr/sbin/nginx这里需要注意 一定是直接用nginx命令启动， 不要用systemctl启动nginx不然会有权限问题10. 通过配置文件启动uwsgi123456789101112131415161718192021222324252627282930313233343536新建uwsgi.ini 配置文件， 内容如下： # mysite_uwsgi.ini file [uwsgi] # Django-related settings # the base directory (full path) chdir = /home/bobby/Projects/MxOnline # Django's wsgi file module = MxOnline.wsgi # the virtualenv (full path) # process-related settings # master master = true # maximum number of worker processes processes = 10 # the socket (use the full path to be safe socket = 127.0.0.1:8000 # ... with appropriate permissions - may be needed # chmod-socket = 664 # clear environment on exit vacuum = true virtualenv = /home/bobby/.virtualenvs/mxonline logto = /tmp/mylog.log注： chdir： 表示需要操作的目录，也就是项目的目录 module： wsgi文件的路径 processes： 进程数 virtualenv：虚拟环境的目录workon mxonlineuwsgi -i 你的目录/Mxonline/conf/uwsgi.ini &amp;访问1http://你的ip地址/]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-微信轰炸小程序]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F05%2F22%2Fpython%E5%BE%AE%E4%BF%A1%E8%BD%B0%E7%82%B8%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言◾基于python，这个小程序是用python写的◾使用的是python第三方库itchat，itchat模块是一位叫littlecodersh的大神写的模块，附上大神的github地址,有兴趣的朋友可以去尝试玩一下itchat模块，很有趣的！！！https://github.com/littlecodersh/ItChat准备◾Python3.6 需要安装python3.6并配置好环境路径◾安装好python后，打开电脑的CMD终端输入pip install itchat安装itchat模块◾需要设置好默认看图软件核心代码import itchatimport timeprint(‘扫一下弹出来的二维码’) itchat.auto_login(hotReload=True) boom_remark_name = input(‘输入你要轰炸的人的微信备注，按回车建继续’) message = input(‘输入你要轰炸的内容，按回车键开始轰炸’) boom_obj = itchat.search_friends(remarkName=boom_remark_name)[0][‘UserName’]while True:time.sleep(0.5) print(‘正在轰炸。。。’) itchat.send_msg(msg=message, toUserName=boom_obj)代码讲解import itchat导入itchat模块import time导入time模块itchat.auto_login(hotReload=True)登录微信，采用热加载的方式登录网页版的微信，会生成一个itchat.pkl的文件，用于保持登录状态，有点类似于cookieboom_remark_name = input(‘输入你要轰炸的人的微信备注，按回车建继续’) 这里一定要输入你给微信好友的备注名，否者无法定位到好友message = input(‘输入你要轰炸的内容，按回车键开始轰炸’)这里输入要轰炸的内容boom_obj = itchat.search_friends(remarkName=boom_remarkname)[0][‘UserName’]这里通过微信好友的备注名找到微信好友的信息，再通过UserName定位到好友while True: 死循环轰炸 time.sleep(0.5)设置睡眠，以免出现消息发送频繁导致不能发送微信消息，此处可自行设置，睡眠时间不能太短 print(‘正在轰炸。。。’) itchat.send_msg(msg=message, toUserName=boom_obj)如何使用◾打开CMD终端◾输入python◾将We.py文件拖入终端◾按回车◾扫一下弹出来的二维码，确认登录微信◾输入你要轰炸的人的微信备注(!!!一定要是微信好友的备注，没有备注请添加备注)◾输入要轰炸的内容◾按回车键开始轰炸如何退出按Ctrl + C 退出轰炸]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>itchat模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django实现数据库读写分离]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F05%2F22%2F%E9%85%8D%E7%BD%AEDjango%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[配置Django实现数据库读写分离django在进行数据库操作的时候，读取数据与写数据（增、删、改）可以分别从不同的数据库进行操作。1. 在配置文件中增加slave数据库的配置123456789101112131415161718DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '10.211.55.', 'PORT': 3306, 'USER': '', 'PASSWORD': '', 'NAME': '' &#125;, 'slave': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '10.211.55.', 'PORT': '', 'USER': 'root', 'PASSWORD': 'mysql', 'NAME': '' &#125;&#125;2. 创建数据库操作的路由分发类在utils中创建db_router.py1234567891011121314class MasterSlaveDBRouter(object): """数据库主从读写分离路由""" def db_for_read(self, model, **hints): """读数据库""" return "slave" def db_for_write(self, model, **hints): """写数据库""" return "default" def allow_relation(self, obj1, obj2, **hints): """是否运行关联操作""" return True3. 配置读写分离路由在配置文件中增加12# 配置读写分离DATABASE_ROUTERS = ['utils.db_router.MasterSlaveDBRouter']]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>python</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题个性化之自动更换背景图片]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F01%2F25%2FNext%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[Next主题个性化之自动更换背景图片如果觉得next的空白主题看腻了或者太多人用觉得不够个性化，那么不妨试试自动更新背景图片（简单且酷）。实现的原理：调用了网站的接口。自动更换背景的实现是修改添加背景的css样式实现。图片来源是 ：https://source.unsplash.com/这个网站，里面不仅免费提供了很多高清美图，而且还提供api接口调用，实在是良心。1 .修改背景样式修改themes\next\source\css\ _custom\custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：body {background:url(https://source.unsplash.com/random/1600x900);background-repeat: no-repeat;background-attachment:fixed;background-position:50% 50%;}如果自己不喜欢这个网址提供的图片做背景，那么修改url()里面的路径即可。repeat、attachment、position就是调整图片的位置，不重复出现、不滚动等等。2.修改不透明度完成这一步其实背景就会自动更换了，但是会出现一个问题，因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。那么就需要调整背景的不透明度了。同样是修改themes\next\source\css\ _custom\custom.styl文件。在后面添加如下代码body {background:url(https://source.unsplash.com/random/1600x900);background-repeat: no-repeat;background-attachment:fixed;background-position:50% 50%;}.content-wrap {opacity: 0.86;}(实际需要根据选择的主题来添加)然后 hexo clean hexo g hexo d 便可以实现了参考链接：https://blog.csdn.net/mango_haoming/article/details/78473243]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2Flinchao1002.github.io%2F2018%2F01%2F22%2FGit%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Git大全推荐一款工具：SourcetreeSourcetree简化了您与Git存储库交互的方式，因此您可以专注于编码。通过Sourcetree的简单Git GUI可视化和管理您的存储库。 https://www.sourcetreeapp.com/git config配置 Git 的相关参数。Git 一共有3个配置文件：\1. 仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。\2. 全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\Users\&lt;用户名&gt;\.gitconfig。\3. 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。123456789101112131415161718192021222324252627282930313233343536373839404142# 查看配置信息# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -l# 查看当前生效的配置信息$ git config -l# 编辑配置文件# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -e# 添加配置项# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;# 获取配置项$ git config &lt;--local | --global | --system&gt; --get &lt;name&gt;# 删除配置项$ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt;# 配置提交记录中的用户信息$ git config --global user.name &lt;用户名&gt;$ git config --global user.email &lt;邮箱地址&gt;# 更改Git缓存区的大小# 如果提交的内容较大，默认缓存较小，提交会失败# 缓存大小单位：B，例如：524288000（500MB）$ git config --global http.postBuffer &lt;缓存大小&gt;# 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态$ git config --global color.ui true# 配置可以缓存密码，默认缓存时间15分钟$ git config --global credential.helper cache# 配置密码的缓存时间# 缓存时间单位：秒$ git config --global credential.helper 'cache --timeout=&lt;缓存时间&gt;'# 配置长期存储密码$ git config --global credential.helper storegit clone从远程仓库克隆一个版本库到本地。12345678# 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下$ git clone &lt;远程仓库的网址&gt;# 指定本地仓库的目录$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;# -b 指定要克隆的分支，默认是master分支$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;git init初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。12# 初始化本地仓库，在当前目录下生成 .git 文件夹$ git initgit status查看本地仓库的状态。1234567# 查看本地仓库的状态$ git status# 以简短模式查看本地仓库的状态# 会显示两列，第一列是文件的状态，第二列是对应的文件# 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中$ git status -sgit remote操作远程库。123456789101112131415161718# 列出已经存在的远程仓库$ git remote# 列出远程仓库的详细信息，在别名后面列出URL地址$ git remote -v$ git remote --verbose# 添加远程仓库$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;# 修改远程仓库的别名$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;# 删除指定名称的远程仓库$ git remote remove &lt;远程仓库的别名&gt;# 修改远程仓库的 URL 地址$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;git branch操作 Git 的分支命令。1234567891011121314151617181920# 列出本地的所有分支，当前所在分支以 "*" 标出$ git branch# 列出本地的所有分支并显示最后一次提交，当前所在分支以 "*" 标出$ git branch -v# 创建新分支，新的分支基于上一次提交建立$ git branch &lt;分支名&gt;# 修改分支名称# 如果不指定原分支名称则为当前所在分支$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 强制修改分支名称$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 删除指定的本地分支$ git branch -d &lt;分支名称&gt;# 强制删除指定的本地分支$ git branch -D &lt;分支名称&gt;git checkout检出命令，用于创建、切换分支等。123456789101112# 切换到已存在的指定分支$ git checkout &lt;分支名称&gt;# 创建并切换到指定的分支，保留所有的提交记录# 等同于 "git branch" 和 "git checkout" 两个命令合并$ git checkout -b &lt;分支名称&gt;# 创建并切换到指定的分支，删除所有的提交记录$ git checkout --orphan &lt;分支名称&gt;# 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响$ git checkout &lt;文件路径&gt;git cherry-pick把已经提交的记录合并到当前分支。12# 把已经提交的记录合并到当前分支$ git cherry-pick &lt;commit ID&gt;git add把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。1234567891011121314# 把指定的文件添加到暂存区中$ git add &lt;文件路径&gt;# 添加所有修改、已删除的文件到暂存区中$ git add -u [&lt;文件路径&gt;]$ git add --update [&lt;文件路径&gt;]# 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录$ git add -A [&lt;文件路径&gt;]$ git add --all [&lt;文件路径&gt;]# 查看所有修改、已删除但没有提交的文件，进入一个子命令系统$ git add -i [&lt;文件路径&gt;]$ git add --interactive [&lt;文件路径&gt;]git commit将暂存区中的文件提交到本地仓库中。123456789101112# 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息$ git commit# 把暂存区中的文件提交到本地仓库中并添加描述信息$ git commit -m "&lt;提交的描述信息&gt;"# 把所有修改、已删除的文件提交到本地仓库中# 不包括未被版本库跟踪的文件，等同于先调用了 "git add -u"$ git commit -a -m "&lt;提交的描述信息&gt;"# 修改上次提交的描述信息$ git commit --amendgit fetch从远程仓库获取最新的版本到本地的 tmp 分支上。12345# 将远程仓库所有分支的最新版本全部取回到本地$ git fetch &lt;远程仓库的别名&gt;# 将远程仓库指定分支的最新版本取回到本地$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;git merge合并分支。12# 把指定的分支合并到当前所在的分支下$ git merge &lt;分支名称&gt;git diff比较版本之间的差异。123456789101112131415161718# 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改$ git diff# 比较暂存区中的文件和上次提交时的差异$ git diff --cached$ git diff --staged# 比较当前文件和上次提交时的差异$ git diff HEAD# 查看从指定的版本之后改动的内容$ git diff &lt;commit ID&gt;# 比较两个分支之间的差异$ git diff &lt;分支名称&gt; &lt;分支名称&gt;# 查看两个分支分开后各自的改动内容$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;git pull从远程仓库获取最新版本并合并到本地。首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。12# 从远程仓库获取最新版本。$ git pullgit push把本地仓库的提交推送到远程仓库。123456# 把本地仓库的分支推送到远程仓库的指定分支$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 删除指定的远程仓库的分支$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;git log显示提交的记录。12345678# 打印所有的提交记录$ git log# 打印从第一次提交到指定的提交的记录$ git log &lt;commit ID&gt;# 打印指定数量的最新提交的记录$ git log -&lt;指定的数量&gt;git reset还原提交记录。12345678910111213141516# 重置暂存区，但文件不受影响# 相当于将用 "git add" 命令更新到暂存区的内容撤出暂存区，可以指定文件# 没有指定 commit ID 则默认为当前 HEAD$ git reset [&lt;文件路径&gt;]$ git reset --mixed [&lt;文件路径&gt;]# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改$ git reset &lt;commit ID&gt;$ git reset --mixed &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改# 相当于调用 "git reset --mixed" 命令后又做了一次 "git add"$ git reset --soft &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了$ git reset --hard &lt;commit ID&gt;git revert生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。12# 生成一个新的提交来撤销某次提交$ git revert &lt;commit ID&gt;git tag操作标签的命令。1234567891011121314151617181920212223# 打印所有的标签$ git tag# 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]# 添加带有描述信息的附注标签，可以指定之前的提交记录$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]# 切换到指定的标签$ git checkout &lt;标签名称&gt;# 查看标签的信息$ git show &lt;标签名称&gt;# 删除指定的标签$ git tag -d &lt;标签名称&gt;# 将指定的标签提交到远程仓库$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;# 将本地所有的标签全部提交到远程仓库$ git push &lt;远程仓库的别名&gt; –tagsgit mv重命名文件或者文件夹。12# 重命名指定的文件或者文件夹$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;git rm删除文件或者文件夹。12345678# 移除跟踪指定的文件，并从本地仓库的文件夹中删除$ git rm &lt;文件路径&gt;# 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除$ git rm -r &lt;文件夹路径&gt;# 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件$ git rm --cachedGit操作场景示例1. 删除掉本地不存在的远程分支多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch --all 依然会显示该远程分支，可使用下列的命令进行删除：123456# 使用 pull 命令，添加 -p 参数$ git pull -p# 等同于下面的命令$ git fetch -p$ git fetch --prune origin]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT 项目开发流程]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F12%2F23%2FWork%2F</url>
    <content type="text"><![CDATA[Work项目开发流程产品经理PRD原型图开会项目评估能不能做多长时间做出来有什么风险UIDBA数据库工程师设计库，表后台设计库，设计表封装Api送测提交Bug修改Bug上Staging演示环境上线凌晨三点版本迭代未雨绸缪研究那些将使用但是还没有使用过的技术协作工具文档协作Google Document有道云协作Trello版本控制Git代码托管仓库GitHub码云gerritgitlabBug反馈平台Bugzilla用户，用户组可以按照应用分配bug为bug分级追踪bugBugly持续集成JenkinsOA管理员工出勤，请假打卡打指纹刷脸钉钉邮件系统企业邮箱记录项目活跃度统计工具自己通过中间件实现专门的统计平台实现友盟统计百度统计xxx统计统计工具项目分析淘票票用户端用户系统纯自己打造用户注册来的电影系统属于后台管理的跳转到选座购票根据时间，根据电影名，根据区域，筛选排期拿着电影ID去电影院中的排档表筛选影院系统属于后台管理的对影院的区域级联筛选，再加评分和综合排序跳转到选座购票影院已经确定可以根据时间和电影去排档中筛选购票选座系统对应的是排档，排档中包含影厅，影厅包含座位布局座位状态确定根据订单来修改座位状态已支付订单 status = 2 已支付懒修改来管理锁单查询锁单订单 status=0 已下单未付款，继续根据时间节点进行联合查询订单将座位号，排档，用户发送给服务器生成订单十五分钟过期有时间戳，当前时间 + 十五分钟锁单真实订单，只不过订单未支付，并且未锁单支付系统内嵌支付宝调用第三方支付宝积分系统点评系统电影院端用户系统电影院注册电影系统后台管理的放映厅影院自己的排档影厅 + 电影 + 时间 + 影院售票和用户的订单生成是一样的只不过订单的用户是default后台管理客户端用户系统只是辅助维护电影院用户辅助维护，认证，信息修改需要后端认证电影系统淘宝直接对接的订单系统都可以查看]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-redis缓存]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F05%2F22%2F%E5%AE%89%E8%A3%85django_redis%2F</url>
    <content type="text"><![CDATA[安装django_redis1pip install django_redisdjango 项目settings.py 文件设置123456789CACHES = &#123; 'default': &#123; 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://127.0.0.1:6379/2', "OPTIONS": &#123; "CLIENT_CLASS": "django_redis.client.DefaultClient", &#125;, &#125;,&#125;然后开启redis，有两种方式启用django的cache，站点缓存1234MIDDLEWARE = [ # 站点缓存 # 'django.middleware.cach//e.UpdateCacheMiddleware', ***页面缓存12345from django.views.decorators.cache import cache_page@cache_page(60)def search(request): maxLength = 9 if request.met以上都是用django的cache的shortcut实现的通过手动cache，具有更大的灵活性123456789101112from django.core.cache import cache def visited_user(request): key='visited' if cache.has_key(key): data = cache.get(key) else: data = get_data() cache.set(key,data,60*60) return datadef get_data() data = Movie.objects.all() return data为visited_user视图配好路由url, 再写好前端页面即可访问但是这个我这个例子不灵活，后期的话可以用celery做后台任务，定时给某些特定模块加载缓存，以提高访问速度]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>redis</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis设置密码登录]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F05%2F12%2FRedis%20%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[一、Redis 设置密码登陆1、默认Redis是没有密码登陆1234567 //本机登录 [root@iZrj98p4hhys0y9fdxmcy4Z yanmin]# redis-cli redis 127.0.0.1:6379&gt; //远程登陆 caiwenhua-d1:notes yanmin$ redis-cli -h 47.88.76.55 -p 637947.88.76.55:6379&gt;远程登陆前提：开启了远程登陆设置2、设置Redis密码登陆A、yum安装redis默认配置文件位置/etc/redis.conf,源码安装一般位置/etc/reids/redis.conf,如果都找不到，可以通过find / -name redis.conf查找123456//默认配置#requirepass foobared //修改配置去掉前面#，并且把foobared修改想要设置的密码，比如：123456requirepass 1234563、Redis重启12345//yum安装启动方式service redis restart//源码安装启动方式redis-server /etc/redis/redis.conf &amp;4、Redis 密码登陆A、默认启动方式12345//本机[root@iZrj98p4hhys0y9fdxmcy4Z yanmin]# redis-cli -h 127.0.0.1 -p 6379redis 127.0.0.1:6379&gt; get name(error) ERR operation not permittedredis 127.0.0.1:6379&gt;B、指定密码方式登陆,成功启动redis123[root@iZrj98p4hhys0y9fdxmcy4Z yanmin]# redis-cli -h 127.0.0.1 -p 6379 -a 123456redis 127.0.0.1:6379&gt; get name"yanmin"C、除了在登录时通过-a参数制定密码外，还可以登录时不指定密码，而在执行操作前进行认证auth password。12345678[root@iZrj98p4hhys0y9fdxmcy4Z yanmin]# redis-cli -h 127.0.0.1 -p 6379 redis 127.0.0.1:6379&gt; get name (error) ERR operation not permitted redis 127.0.0.1:6379&gt; auth 123456 OK redis 127.0.0.1:6379&gt; get name "yanmin" redis 127.0.0.1:6379&gt;5、通过命令修改配置A、登陆redis服务12[root@iZrj98p4hhys0y9fdxmcy4Z yanmin]# redis-cli -h 127.0.0.1 -p 6379 -a 123456redis 127.0.0.1:6379&gt;B、修改redis密码12redis 127.0.0.1:6379&gt; config set requirepass yanminOKC、使用新密码登陆，无需重启Redis123[root@iZrj98p4hhys0y9fdxmcy4Z yanmin]# redis-cli -h 127.0.0.1 -p 6379 -a yanminredis 127.0.0.1:6379&gt; get name"yanmin"D、重启Redis以后，发现新密码已经失效，Redis重新使用配置文件中的密码12345678[root@iZrj98p4hhys0y9fdxmcy4Z yanmin]# redis-cli -h 127.0.0.1 -p 6379 -a yanminredis 127.0.0.1:6379&gt; get name(error) ERR operation not permittedredis 127.0.0.1:6379&gt;[root@iZrj98p4hhys0y9fdxmcy4Z yanmin]# redis-cli -h 127.0.0.1 -p 6379 -a 123456redis 127.0.0.1:6379&gt; get name"yanmin"redis 127.0.0.1:6379&gt;转自：http://www.yanmin99.com]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F03%2F20%2FLinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux命令Linux命令查询：http://man.linuxde.net/Linux命令详解]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识linux]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F03%2F12%2F2017-03-12-%E5%88%9D%E8%AF%86linux%2F</url>
    <content type="text"><![CDATA[Linux的发行版目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等Linux vs Windows目前国内Linux更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下比较WindowsLinux界面界面统一，外壳程序固定所有Windows程序菜单几乎一致，快捷键也几乎相同图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux的终端机是从UNIX传承下来，基本命令和操作方法也几乎一致。驱动程序驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的Windows下的驱动，也会比较头痛。由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。使用使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。图形界面使用简单，容易入门。文字界面，需要学习才能掌握。学习系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。软件每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。大部分软件都可以自由获取，同样功能的软件选择较少。深入学习：http://www.runoob.com/linux/linux-tutorial.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux（centos）源码redis安装]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F03%2F05%2FLinux%EF%BC%88centos%EF%BC%89%20%E6%BA%90%E7%A0%81redis%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一、Reids介绍Redis官网REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。二、Reids准备检查安装依赖程序123yum install gcc-c++yum install -y tclyum install wget三、安装文件下载1wget http://download.redis.io/releases/redis-2.8.13.tar.gz四、解压到指定目录123456//解压文件tar xzf redis-4.0.1.tar.gz//把文件移动到指定目录mv redis-4.0.1 /usr/local/redis//进入到指定目录cd /usr/local/redis五、编译、安装12makemake install六、设置配置文件路径12mkdir -p /etc/rediscp redis.conf/etc/redismkdir -p: -p表示递归创建文件夹七、设置配置文件,daemonize介绍123vi /etc/redis/redis.conf//把no修改为yesdaemonize yes （no--&gt;yes）八、Redis启动1redis-server /etc/redis/redis.conf &amp;&amp; 代表后台启动。九、查看是否启动1、查看进程名12[root@node404v /usr/local/redis]# ps aux|grep redisroot 15720 0.0 0.0 143904 2244 ? Ssl 15:10 0:00 redis-server 127.0.0.1:63792、查看端口是否监听12[root@node404v /usr/local/redis]# netstat -ntlp | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 32246/mysqld十、使用客户端通过redis-cli启动客户端redis实例123456[root@node404v /usr/local/redis]# redis-cli127.0.0.1:6379&gt; set age 10OK127.0.0.1:6379&gt; get age"10"127.0.0.1:6379&gt;通过ctr+c 或者 exit退出。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题添加pdf]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F01%2F25%2Fhexo-next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0pdf%2F</url>
    <content type="text"><![CDATA[next 添加支持 pdf安装npm install –save hexo-pdf使用外部链接1&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125;内部链接【在博客source\_posts\，文件夹下创建一个文章如**.md,同时需要再创建一个文件夹，放我们要上传的PDF文章 】1&#123;% pdf /hexo/next-pdf/1.pdf %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 主题添加分享功能]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F01%2F23%2F2019-1-24%20Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD%20121259%2F</url>
    <content type="text"><![CDATA[Next主题添加分享功能next主题自带的jiathis分享功能（2018年4月已停止 http://www.lwd3699.com/keji/1564.html）打开主next主题配置文件_config.yml ,搜索jiathis,改为true即可123# Warning: JiaThis does not support https.(不支持https)jiathis: true ##uid: Get this uid from http://www.jiathis.com/next主题自带的百度分享功能：参考链接：https://asdfv1929.github.io/2018/05/25/baidu-share/打开主next主题配置文件_config.yml ,搜索baidushare,添加如下配置（其中 type 亦可以选择 slide)：123baidushare: type: button baidushare: true #新增由于baidushare不支持https，解决方法便是，将static文件夹解压保存至themes\next\source目录下 。static文件链接： https://github.com/hrwhisper/baiduShare修改文件：themes\next\layout_partials\share\baidushare.swig将文件 末尾 部分的代码进行修改：1.src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];改为： 1.src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];最后重新生成下，就能展示分享功能了。NexT主题添加ShareSDK的分享：传送门 ：ShareSDK​]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>ShareSDK分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试中的公共问题]]></title>
    <url>%2Flinchao1002.github.io%2F2017%2F01%2F02%2F%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%85%AC%E5%85%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试中的公共问题计算机基础TCP/IP模型相关问题。建议阅读阮一峰的《互联网协议入门（一）》和《互联网协议入门（二）》。HTTP和HTTPS相关问题。建议阅读阮一峰的《HTTP 协议入门》和《SSL/TLS协议运行机制的概述》。Linux常用命令和服务。进程和线程之间的关系。什么时候用多线程？什么时候用多进程？。关系型数据库相关问题（ACID、事务隔离级别、锁、SQL优化）。非关系型数据库相关问题（CAP/BASE、应用场景）。Python基础开发中用过哪些标准库和三方库。标准库：sys / os / re / math / random / logging / json / pickle / shelve / socket / datetime / hashlib / configparser / urllib / itertools / collections / functools / threading / multiprocess / timeit / atexit / abc / asyncio / base64 / concurrent.futures / copy / csv / operator / enum / heapq / http / profile / pstats / ssl / unitest / uuid装饰器的作用、原理和实现。使用过哪些魔法方法。建议阅读《Python魔术方法指南》。生成式、生成器、迭代器的编写。列表、集合、字典的底层实现。垃圾回收相关问题。并发编程的相关问题。协程和异步I/O相关知识。Django和FlaskMVC架构（MTV）解决了什么问题。中间件的执行流程以及如何自定义中间件。REST数据接口如何设计（URL、域名、版本、过滤、状态码、安全性）。建议阅读阮一峰的《RESTful API设计指南》。使用ORM框架实现CRUD操作的相关问题。如何实现多条件组合查询 / 如何执行原生的SQL / 如何避免N+1查询问题如何执行异步任务和定时任务。如何实现页面缓存和查询缓存？缓存如何预热？爬虫相关Scrapy框架的组件和数据处理流程。爬取的目的（项目中哪些地方需要用到爬虫的数据）。使用的工具（抓包、下载、清理、存储、分析、可视化）。数据的来源（能够轻松的列举出10个网站）。数据的构成（抓取的某个字段在项目中有什么用）。反反爬措施（限速、请求头、Cookie池、代理池、Selenium、PhantomJS、RoboBrowser、TOR、OCR）。数据的体量（最后抓取了多少数据，多少W条数据或多少个G的数据）。后期数据处理（持久化、数据补全、归一化、格式化、转存、分类）。数据分析科学运算函数库（SciPy和NumPy常用运算）。数据分析库（Pandas中封装的常用算法）。常用的模型及对应的场景（分类、回归、聚类）。提取了哪些具体的指标。如何评价模型的优劣。每种模型实际操作的步骤，对结果如何评价。项目相关项目团队构成以及自己在团队中扮演的角色（在项目中的职责）。项目的业务架构（哪些模块及子模块）和技术架构（移动端、PC端、后端技术栈）。软件控制管理相关工具（版本控制、问题管理、持续集成）。核心业务实体及其属性，实体与实体之间的关系。用到哪些依赖库，依赖库主要解决哪方面的问题。项目如何部署上线以及项目的物理架构（Nginx、Gunicorn/uWSGI、Redis、MongoDB、MySQL、Supervisor等）。如何对项目进行测试，有没有做过性能调优。项目中遇到的困难有哪些，如何解决的。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Flinchao1002.github.io%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Flinchao1002.github.io%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[About]]></title>
    <url>%2Flinchao1002.github.io%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[简介：星座：天秤座/Boy邮箱: linchao1002@qq.com歡迎收藏本站，下面留言會盡可能答復 (右下角可以实时联系哦，方便尽快回复你)]]></content>
  </entry>
</search>
