<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Linchao&#39;s Blog</title>
  
  <subtitle>身体和灵魂总要有一个在路上</subtitle>
  <link href="/linchao1002.github.io/atom.xml" rel="self"/>
  
  <link href="https//linchao1002.github.io/"/>
  <updated>2019-01-25T03:53:46.389Z</updated>
  <id>https//linchao1002.github.io/</id>
  
  <author>
    <name>Hou Linchao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Next主题个性化之自动更换背景图片</title>
    <link href="https//linchao1002.github.io/2019/01/25/Next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/"/>
    <id>https//linchao1002.github.io/2019/01/25/Next主题个性化之自动更换背景图片/</id>
    <published>2019-01-25T12:14:49.000Z</published>
    <updated>2019-01-25T03:53:46.389Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 25 2019 13:11:42 GMT+0800 (GMT+08:00) --><h2 id="Next主题个性化之自动更换背景图片"><a href="#Next主题个性化之自动更换背景图片" class="headerlink" title="Next主题个性化之自动更换背景图片"></a>Next主题个性化之自动更换背景图片</h2><p>如果觉得next的空白主题看腻了或者太多人用觉得不够个性化，那么不妨试试自动更新背景图片（简单且酷）。</p><p>实现的原理：调用了网站的接口。<br>自动更换背景的实现是修改添加背景的css样式实现。图片来源是 ：<a href="https://source.unsplash.com/" target="_blank" rel="noopener">https://source.unsplash.com/</a></p><p>这个网站，里面不仅免费提供了很多高清美图，而且还提供api接口调用，实在是良心。<br><a id="more"></a></p><h6 id="1-修改背景样式"><a href="#1-修改背景样式" class="headerlink" title="1 .修改背景样式"></a>1 .修改背景样式</h6><p>修改themes\next\source\css\ _custom\custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：</p><p>body {<br>background:url(<a href="https://source.unsplash.com/random/1600x900)" target="_blank" rel="noopener">https://source.unsplash.com/random/1600x900)</a>;<br>background-repeat: no-repeat;<br>background-attachment:fixed;<br>background-position:50% 50%;<br>}<br>如果自己不喜欢这个网址提供的图片做背景，那么修改url()里面的路径即可。repeat、attachment、position就是调整图片的位置，不重复出现、不滚动等等。</p><h6 id="2-修改不透明度"><a href="#2-修改不透明度" class="headerlink" title="2.修改不透明度"></a>2.修改不透明度</h6><p>完成这一步其实背景就会自动更换了，但是会出现一个问题，因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。</p><p>那么就需要调整背景的不透明度了。同样是修改themes\next\source\css\ _custom\custom.styl文件。在后面添加如下代码</p><p>.main-inner {<br>margin-top: 60px;<br>padding: 60px 60px 60px 60px;<br>background: #fff;<br>opacity: 0.8;<br>min-height: 500px;<br>}<br>background: #fff; 白色 opacity: 0.8;不透明度</p><p>然后 hexo clean hexo g hexo d 便可以实现了</p><p>参考链接：<a href="https://blog.csdn.net/mango_haoming/article/details/78473243" target="_blank" rel="noopener">https://blog.csdn.net/mango_haoming/article/details/78473243</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Jan 25 2019 13:11:42 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Next主题个性化之自动更换背景图片&quot;&gt;&lt;a href=&quot;#Next主题个性化之自动更换背景图片&quot; class=&quot;headerlink&quot; title=&quot;Next主题个性化之自动更换背景图片&quot;&gt;&lt;/a&gt;Next主题个性化之自动更换背景图片&lt;/h2&gt;&lt;p&gt;如果觉得next的空白主题看腻了或者太多人用觉得不够个性化，那么不妨试试自动更新背景图片（简单且酷）。&lt;/p&gt;&lt;p&gt;实现的原理：调用了网站的接口。&lt;br&gt;自动更换背景的实现是修改添加背景的css样式实现。图片来源是 ：&lt;a href=&quot;https://source.unsplash.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://source.unsplash.com/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这个网站，里面不仅免费提供了很多高清美图，而且还提供api接口调用，实在是良心。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https//linchao1002.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https//linchao1002.github.io/tags/Hexo/"/>
    
      <category term="Next" scheme="https//linchao1002.github.io/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Next 主题添加分享功能</title>
    <link href="https//linchao1002.github.io/2019/01/23/2019-1-24%20Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD%20121259/"/>
    <id>https//linchao1002.github.io/2019/01/23/2019-1-24 Next主题添加分享功能 121259/</id>
    <published>2019-01-23T12:14:49.000Z</published>
    <updated>2019-01-24T07:27:53.827Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 25 2019 13:11:42 GMT+0800 (GMT+08:00) --><h1 id="Next主题添加分享功能"><a href="#Next主题添加分享功能" class="headerlink" title="Next主题添加分享功能"></a>Next主题添加分享功能</h1><ol><li><p>next主题自带的jiathis分享功能（2018年4月已停止 <a href="http://www.lwd3699.com/keji/1564.html）" target="_blank" rel="noopener">http://www.lwd3699.com/keji/1564.html）</a></p><p>打开主next主题配置文件_config.yml ,搜索jiathis,改为true即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Warning: JiaThis does not support https.(不支持https)</span><br><span class="line">jiathis: true</span><br><span class="line">  ##uid: Get this uid from http://www.jiathis.com/</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>next主题自带的百度分享功能：</p><p>参考链接：<a href="https://asdfv1929.github.io/2018/05/25/baidu-share/" target="_blank" rel="noopener">https://asdfv1929.github.io/2018/05/25/baidu-share/</a></p><p>打开主next主题配置文件_config.yml ,搜索baidushare,添加如下配置（其中 type 亦可以选择 slide)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baidushare:</span><br><span class="line">  type: button    </span><br><span class="line">  baidushare: true #新增</span><br></pre></td></tr></table></figure><p>由于baidushare不支持https，解决方法便是，将<code>static</code>文件夹解压保存至<code>themes\next\source</code>目录下 。</p><p>static文件链接： <a href="https://github.com/hrwhisper/baiduShare" target="_blank" rel="noopener">https://github.com/hrwhisper/baiduShare</a></p><p>修改文件：<code>themes\next\layout_partials\share\baidushare.swig</code></p><p>将文件 <strong>末尾</strong> 部分的代码进行修改：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.src=&apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];</span><br></pre></td></tr></table></figure><pre><code>改为：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.src=&apos;/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];</span><br></pre></td></tr></table></figure><p>最后重新生成下，就能展示分享功能了。</p><ol start="3"><li><p>NexT主题添加ShareSDK的分享：</p><p>传送门 ：<a href="https://blog.csdn.net/Captain_Magicer/article/details/54413833" target="_blank" rel="noopener">ShareSDK</a></p></li></ol><p>​</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Jan 25 2019 13:11:42 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Next主题添加分享功能&quot;&gt;&lt;a href=&quot;#Next主题添加分享功能&quot; class=&quot;headerlink&quot; title=&quot;Next主题添加分享功能&quot;&gt;&lt;/a&gt;Next主题添加分享功能&lt;/h1&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;next主题自带的jiathis分享功能（2018年4月已停止 &lt;a href=&quot;http://www.lwd3699.com/keji/1564.html）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.lwd3699.com/keji/1564.html）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;打开主next主题配置文件_config.yml ,搜索jiathis,改为true即可&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Warning: JiaThis does not support https.(不支持https)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jiathis: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ##uid: Get this uid from http://www.jiathis.com/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https//linchao1002.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https//linchao1002.github.io/tags/Hexo/"/>
    
      <category term="Next" scheme="https//linchao1002.github.io/tags/Next/"/>
    
      <category term="ShareSDK分享" scheme="https//linchao1002.github.io/tags/ShareSDK%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Next 主题添加站内搜索功能</title>
    <link href="https//linchao1002.github.io/2019/01/23/Next%20%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
    <id>https//linchao1002.github.io/2019/01/23/Next 主题添加站内搜索功能/</id>
    <published>2019-01-23T12:14:49.000Z</published>
    <updated>2019-01-24T07:27:34.879Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 25 2019 13:11:42 GMT+0800 (GMT+08:00) --><h1 id="Next-主题添加站内搜索功能"><a href="#Next-主题添加站内搜索功能" class="headerlink" title="Next 主题添加站内搜索功能"></a>Next 主题添加站内搜索功能</h1><p>详细请看：<a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">https://github.com/wzpan/hexo-generator-search</a></p><ul><li>安装 <code>hexo-generator-searchdb</code>, 站点根目录执行以下命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb  --save</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>编辑 <code>站点配置文件</code>, 新增以下内容到任意位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">    path: search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure><ul><li>编辑 <code>主题配置文件</code>, 启用本地搜索功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p>如果出现点击搜索一直停留在加载状态，可能是文件编码问题，可以在本地测试时访问根目录下 <code>search.xml</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:4000/search.xml</span><br></pre></td></tr></table></figure><p>查看报错信息</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Jan 25 2019 13:11:42 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Next-主题添加站内搜索功能&quot;&gt;&lt;a href=&quot;#Next-主题添加站内搜索功能&quot; class=&quot;headerlink&quot; title=&quot;Next 主题添加站内搜索功能&quot;&gt;&lt;/a&gt;Next 主题添加站内搜索功能&lt;/h1&gt;&lt;p&gt;详细请看：&lt;a href=&quot;https://github.com/wzpan/hexo-generator-search&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/wzpan/hexo-generator-search&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;安装 &lt;code&gt;hexo-generator-searchdb&lt;/code&gt;, 站点根目录执行以下命令&lt;/li&gt;&lt;/ul&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-searchdb  --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https//linchao1002.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https//linchao1002.github.io/tags/Hexo/"/>
    
      <category term="Next" scheme="https//linchao1002.github.io/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Python数据分析基础知识</title>
    <link href="https//linchao1002.github.io/2019/01/23/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>https//linchao1002.github.io/2019/01/23/数据分析/</id>
    <published>2019-01-23T12:14:49.000Z</published>
    <updated>2019-01-24T02:24:51.346Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 25 2019 13:11:42 GMT+0800 (GMT+08:00) --><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="1-工具"><a href="#1-工具" class="headerlink" title="1.工具"></a>1.工具</h2><p><strong>Jupyter Notebook</strong></p><p>运行命令 ：jupyter notebook</p><p>快捷键：</p><ul><li><strong>Enter</strong> : 转入编辑模式</li><li><strong>Shift-Enter</strong> : 运行本单元，选中下个单元</li><li><strong>Ctrl-Enter</strong> : 运行本单元</li><li><strong>Alt-Enter</strong> : 运行本单元，在其下插入新单元</li><li><p><strong>A</strong> : 在上方插入新单元</p><a id="more"></a></li><li><p><strong>B</strong> : 在下方插入新单元</p></li><li><strong>D,D</strong> : 删除选中的单元</li><li><strong>Tab</strong> : 代码补全或缩进</li><li><strong>M</strong> ： 单元转入markdown状态</li><li><strong>shift-Tab</strong> : 提示</li><li>Ctrl-A ：全选</li><li>Ctrl -Z : 复原<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%time      运行计时,耗时长的代码</span><br><span class="line">%timeit   (准确点)，耗时短的代码</span><br><span class="line">%matoplotlib   数据可视化</span><br><span class="line"></span><br><span class="line">%who       快速查看当前会话的所有变量与函数</span><br><span class="line">%who_ls     返回一个列表，，函数 </span><br><span class="line">%lsmagic    列出所有魔法命令</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-numpy"><a href="#2-numpy" class="headerlink" title="2.numpy"></a>2.numpy</h2><ul><li><p>导入库</p><p>import numpy as np</p></li><li><p>创建ndarray</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">   &quot;- numpy默认ndarray的所有元素的类型是相同的&quot;,</span><br><span class="line">   &quot;- 如果传进来的列表中包含不同的类型，则统一为同一类型，优先级str&gt;float&gt;int&quot;</span><br><span class="line">   </span><br><span class="line">    data  =  [1,2,3,4]</span><br><span class="line">    nd = np.array(data)</span><br><span class="line">    nd </span><br><span class="line">    </span><br><span class="line">    nd.dtype : 数据分析，分析的是什么类型的数据</span><br><span class="line">    nd.shape :  数据形状</span><br></pre></td></tr></table></figure><ul><li><p>数据可视化包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.imread()</span><br><span class="line">plt.imshow()</span><br></pre></td></tr></table></figure></li><li><p>np.ones() ,np.zeros() ,np.full( fill_value) fill_value 填值</p><p>np.reshape() 重新定义形状，给数组一个新的形状而不改变其数据</p><p>np.eye() 矩阵 单元矩阵</p><p>numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</p><p>在指定的间隔内返回均匀间隔的数字。</p><p>np.arange( )</p><p>np.random.randint(a, b, size=(c, d)) #指定生成随机数范围和生成的多维数组大小</p><p>np.random.randn(d0, d1, …, dn) 标准正太分布 ,数据就是两边低中间高的数据</p><p>np.random.normal(mean,stdev,size) 给出均值为mean，标准差为stdev的高斯随机数（场），当size赋值时，例如：size=100，表示返回100个高斯随机数</p><p>np.random.random() 生成0到1的随机数，左闭右开</p><p>astype( “uint8”) 将数据转换成uint8</p></li></ul><h2 id="3-ndarray的属性与基本操作"><a href="#3-ndarray的属性与基本操作" class="headerlink" title="3.ndarray的属性与基本操作"></a>3.ndarray的属性与基本操作</h2><ul><li><p>4个必记参数 ： ndim维度 shape形状(各种维度的长度) size总长度 dtype 元素类型</p></li><li><p>索引 ：一维与列表完全一致，多维时同理</p><p>nd[1] nd[1,1]</p><p>根据索引修改数据 nd[2,2] =1000</p></li><li><p>切片 ： 一维与列表完全一致，多维时同理</p><p>广播机制 ： 如果赋值的数据不充分的话，会自动填充</p></li><li><p>变形 ： 使用reshape函数，注意参数是一个tuple</p></li><li><p><strong>级联</strong></p><p>np.concatenate() 级联的参数是一个列表，一定要加中括号或者小括号</p><p>​ 维度必须相同 ，形状相符</p><p>​ <strong>级联的方向默认是shape这个tuple的第一个值所代表的维度方向</strong></p><p>​ <strong>可通过axis 参数改变级联的方向</strong></p><p>np.hstack 水平级联 二维变一维</p><p>np.vstack 垂直级联 一维变二维</p></li><li><p>切分</p><p>np.split np.vsplit np.hsplit</p></li><li><p>ndarray 聚合操作</p><p>axis参数：<br>当axis=0时，对列进行聚合操作；<br>当axis=1时，对行进行聚合操作。<br>求和np.sum： np.sum和np.nansum的区别 nan not a number</p><p>最大最小值np.max/np.min:</p><p>平均值np.mean：</p></li><li><p>矩阵操作</p><h5 id="ndarray的矩阵操作"><a href="#ndarray的矩阵操作" class="headerlink" title="ndarray的矩阵操作"></a>ndarray的矩阵操作</h5><p>广播机制：</p><ul><li>规则一：为缺失的维度补1(维度只能相差1)</li><li>规则二：缺失元素用已有元素补充</li><li>规则三：缺失维度的矩阵只能有一行或者一列</li><li>​</li></ul><p>算数运算 np.add(a+b) / a+b</p><p>矩阵积 np.dot()</p></li><li><h5 id="ndarray排序"><a href="#ndarray排序" class="headerlink" title="ndarray排序"></a>ndarray排序</h5><p>1.快速排序：<br>np.sort()与ndarray.sort()都可以，但有区别：<br>np.sort()不改变输入<br>ndarray.sort()本地处理，不占用空间，但改变输</p><p>2.部分排序：<br>np.partition(a,k)<br>有的时候我们不是对全部数据感兴趣，我们可能只对最小或最大的一部分感兴趣。<br>当k为正时，我们想要得到最小的k个数 , 当k为负时，我们想要得到最大的k个数：</p></li></ul><h2 id="4-cv2-人脸更换"><a href="#4-cv2-人脸更换" class="headerlink" title="4 cv2   人脸更换"></a>4 cv2 人脸更换</h2><ul><li><p>opencv : 计算机视觉库</p></li><li><p>终端下载 : pip install opencv_python</p></li><li><p>cv2在读的时候采用的是<strong>BGR</strong></p></li><li><p>例子 ：</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sanpang = cv2.imread(&quot;./cv2_change_head/j.jpg&quot;)</span><br><span class="line">plt.imshow(sanpang[::,::,::-1])</span><br><span class="line"></span><br><span class="line">#CascadeClassifier:用来处理算法的类</span><br><span class="line">cascade = cv2.CascadeClassifier()</span><br><span class="line"></span><br><span class="line">#加载现成的算法</span><br><span class="line">cascade.load(&apos;./cv2_change_head/haarcascade_frontalface_default.xml&apos;)</span><br><span class="line"></span><br><span class="line">#使用人脸识别的类进行识别</span><br><span class="line">face = cascade.detectMultiScale(sanpang)</span><br><span class="line">face</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-pandas的数据结构"><a href="#5-pandas的数据结构" class="headerlink" title="5. pandas的数据结构"></a>5. pandas的数据结构</h2><p>导入 import pandas as pd</p><p>​ import pandas import Series ,DataFrame</p><p><strong>Series</strong></p><p>​ Series 是一种类似与一维数组的对象，由两个部分组成：</p><ul><li><p>values 一组数据(ndarray 类型)</p></li><li><p>index 相关的数据索引标签</p></li></ul><p>1.创建Series (一一对应，不能多也不能少 （索引和value值）)</p><p>​ (1) 由列表或numpy数组创建 ，默认索引为 0 – N-1的整数型索引</p><p>​ 例： s = Series([1,2,4])</p><p>​ s= Series(np.aarray([1,2,3]), index=list(“abc”))</p><p>​ (2) 由字典创建 (指定索引可多可少，多得情况补上NaN)</p><p>​ s = Series (data ={“a”:10,”b”:22,”c”:33},index ={“a”,”pi”,”c”}</p><p>2 .Series的索引和切片</p><p>​ 可以使用中括号取单个索引（此时返回的是元素类型），或者中括号里一个列表取多 个索引（此时返回的仍然是一个Series类型）。分为显示索引和隐式索引：</p><p>(1) 显式索引：</p><pre><code>- 使用index中的元素作为索引值- 使用.loc[]（推荐）</code></pre><p>注意，此时是闭区间</p><p>​ (2) 隐式索引：</p><pre><code>- 使用整数作为索引值- 使用.iloc[]（推荐）</code></pre><p>注意，此时是半开区间</p><p>​ 3 .Series 的基本概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(1) 可以把Series看成一个定长的有序字典</span><br><span class="line"></span><br><span class="line">       (2)可以通过shape，size，index,values等得到series的属性</span><br><span class="line"></span><br><span class="line">       (3)可以通过head()  ,  tail()快速查看Series对象的样式</span><br><span class="line">           data.head()  参数可以设置数量</span><br><span class="line">           data.tail()</span><br><span class="line">                    </span><br><span class="line">       (4)当索引没有对应的值时，可能出现缺失数据显示NaN（not a number）的情况</span><br><span class="line"></span><br><span class="line">       (5) 可以使用pd.isnull()，pd.notnull()，或自带isnull(),notnull()函数检测缺失数据                </span><br><span class="line">       </span><br><span class="line">        #通过isnull这个函数获取boolean数据的值， 可以把它当成一个检索</span><br><span class="line">        会取出为True的数据，也就是空值， 对空值进行赋值</span><br><span class="line">        例子：   ind = s.isnull()</span><br><span class="line">                s[ind] = np.nan</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">        (6)Series对象本身及其实例都有一个name属性</span><br><span class="line">        s = Series(data = np.random.randint(0,150,size = 5), index = [&quot;张三&quot;,&quot;李                    四&quot;,&quot;Sara&quot;,&quot;Lisa&quot;,&quot;Michael&quot;]</span><br><span class="line">        )</span><br><span class="line">        s.name = &quot;Python&quot;</span><br><span class="line">        s</span><br></pre></td></tr></table></figure><p>​</p><p>4 .Series 的运算</p><p>​ (1) 适用于numpy的数组运算也适用于Series</p><p>​ 加减乘除 ： add subtract multiply divide</p><p>​ (2) series之间的运算 ： 运算中自动对齐不同索引的数据</p><p>​ 如果索引不对应，补NaN</p><p>​ 要想保留所有的index,则需要使用 .add()函数</p><p>二 .<strong>DataFrame</strong></p><p>​ DataFrame是一个【表格型】的数据结构，可以看做是【由Series组成的字典】（共用同一个 索引）。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。</p><ul><li>行索引：index</li><li>列索引：columns</li><li>值：values（numpy的二维数组）</li></ul><ol><li>创建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df1 = DataFrame(&#123;&apos;Python&apos;:[99,101,120,78],</span><br><span class="line">                 &quot;数学&quot;:[120,136,141,129],</span><br><span class="line">                &quot;语文&quot;:[123,114,130,117]&#125;, index = list(&quot;abcd&quot;),</span><br><span class="line">               columns = [&quot;Python&quot;,&quot;数学&quot;,&quot;语文&quot;,&quot;英语&quot;])</span><br><span class="line">df1</span><br><span class="line">行还是一对一的， 列可多可少</span><br></pre></td></tr></table></figure><p>2 .DataFrame属性</p><p>​ values , columns , index , shape</p><p>3 . DataFrame的索引</p><p>​ (1) 对列进行索引</p><pre><code>- 通过类似字典的方式   df2[&quot;python&quot;]         两列数据： df2[[&quot;Python&quot;,&quot;php&quot;]]- 通过属性的方式 - 列切片是不行的</code></pre><p>可以将DataFrame的列获取为一个Series。返回的Series拥有原DataFrame相同的索引，且name属性也已经设置好了，就是相应的列名。</p><p>​</p><p>​ (2) 对行进行索引</p><p>​ <strong><em>#行索引不能使用中括号！！！！！！</em></strong></p><pre><code>- 使用.ix[]来进行行索引- 使用.loc[]加index来进行行索引   #对行数据进行切片, 左闭右闭    df2.loc[&quot;a&quot;:&quot;b&quot;]- 使用.iloc[]加整数来进行行索引    df2.iloc[0:3]   #左闭右开的情况   #loc全部是左闭右闭   在切片的时候 iloc全部是左闭右开的 </code></pre><p>同样返回一个Series，index为原来的columns。</p><p>​ (3) 对元素索引的方法</p><pre><code>- 使用列索引- 使用行索引(iloc[3,1]相当于两个参数;iloc[[3,3]] 里面的[3,3]看做一个参数)- 使用values属性（二维numpy数组）</code></pre><p>​ df2.loc[“a”,”Java”]#总结：进行元素索引的时候，老老实实的行是行，列是列</p><p>【注意】直接用中括号时：</p><ul><li>索引表示的是列索引</li><li>切片表示的是行切片</li></ul><p>4 .DataFrame之间的运算</p><p>（1） DataFrame之间的运算</p><p>同Series一样：</p><ul><li>在运算中自动对齐不同索引的数据</li><li>如果索引不对应，则补NaN</li><li>例： df1.add(df2, fill_value=0) fill_value 添值</li></ul><p>（2） Series与DataFrame之间的运算<strong><em>（注意axis 轴）</em></strong></p><p>【重要】</p><ul><li><p>使用Python操作符：以行为单位操作（参数必须是行），对所有行都有效。（类似于numpy中二维数组与一维数组的运算，但可能出现NaN）</p></li><li><p>使用pandas操作函数：</p><pre><code>axis=0：以列为单位操作（参数必须是列），对所有列都有效。axis=1：以行为单位操作（参数必须是行），对所有行都有效。</code></pre></li></ul><p><strong>三 . 处理丢失数据</strong></p><p>​ numpy 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">有两种丢失数据  ： None      np.nan(NaN)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  1.None</span><br><span class="line"></span><br><span class="line">         None是Python自带的，其类型为python object。因此，None不能参与到任何计算中。</span><br><span class="line"></span><br><span class="line">         object类型的运算要比int类型的运算慢得多  </span><br><span class="line"></span><br><span class="line">         计算不同数据类型求和时间  </span><br><span class="line"></span><br><span class="line">         %timeit np.arange(1e5,dtype=xxx).sum()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   2.np.nan(NaN)</span><br><span class="line"></span><br><span class="line">         np.nan是浮点类型，能参与到计算中。但计算的结果总是NaN。</span><br><span class="line"></span><br><span class="line">         但可以使用np.nan*()函数来计算nan，此时视nan为0。</span><br></pre></td></tr></table></figure><p>pandas中None和np.nan都视作np.nan</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例子  ：df = DataFrame([[10,20,57,np.nan,None],</span><br><span class="line">                [22,33,56,12,None],</span><br><span class="line">                [np.nan,1,2,3,4]], index = list(&quot;abc&quot;),</span><br><span class="line">              columns = [&quot;Python&quot;,&quot;Java&quot;,&quot;数学&quot;,&quot;物理&quot;,&quot;H5&quot;])</span><br><span class="line">#三行五列</span><br><span class="line">df</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>Python</th><th>JAVA</th><th>数学</th><th>物理</th><th>H5</th></tr></thead><tbody><tr><td>a</td><td>10.0</td><td>20</td><td>57</td><td>NaN</td><td>NaN</td></tr><tr><td>b</td><td>22.0</td><td>33</td><td>56</td><td>12.0</td><td>NaN</td></tr><tr><td>c</td><td>NaN</td><td>1</td><td>2</td><td>3.0</td><td>4.0</td></tr></tbody></table><p>pandas中None与np.nan的操作</p><p>​ isnull()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：isnull().any()     查看数据  行或者列  是否有空值</span><br></pre></td></tr></table></figure><p>​ notnull()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：  isnull和any 使用     notnull和all使用</span><br></pre></td></tr></table></figure><p>​ dropna() 过滤丢失数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数  how  = &quot;all&quot;   axis</span><br></pre></td></tr></table></figure><p>​ fillna() 填冲充丢数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以选择前向填充还是后向填充</span><br><span class="line">前  :df3.fillna(method=&quot;ffill&quot;)     #forward</span><br><span class="line">后  :df3.fillna(method=&quot;bfill&quot;)      #back</span><br><span class="line">左  : df3.fillna(method=&quot;bfill&quot;,axis = 1)   </span><br><span class="line">右  :df3.fillna(method=&quot;ffill&quot;,axis = 1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#扩展</span><br><span class="line">cond = (df3 &gt;= 10).all(axis = 1)</span><br></pre></td></tr></table></figure><h2 id="6-pandas层次化索引"><a href="#6-pandas层次化索引" class="headerlink" title="6.pandas层次化索引"></a>6.pandas层次化索引</h2><p>​ 1.创建多层行索引</p><p>​ (1) 隐式构造</p><p>​ 最常见的方法是给DataFrame构造函数的index参数传递两个或者更多的数组</p><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#隐式创建</span><br><span class="line">s = Series(data = [1,2,3,&quot;a&quot;], </span><br><span class="line">          index = [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;期中&quot;,&quot;期末&quot;,&quot;期中&quot;,&quot;期末&quot;]])</span><br><span class="line">s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#二层索引</span><br><span class="line">df = DataFrame(data = [1,2,3,&quot;a&quot;],</span><br><span class="line">               index = [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;期中&quot;,&quot;期末&quot;,&quot;期中&quot;,&quot;期末&quot;]],</span><br><span class="line">              columns = [&quot;Python&quot;])</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#三层索引</span><br><span class="line">df = DataFrame(data = np.random.randint(0,150,size = 8),</span><br><span class="line">              index = [[&apos;a&apos;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;],</span><br><span class="line">                       [&apos;期中&apos;,&quot;期中&quot;,&quot;期末&quot;,&quot;期末&quot;,&apos;期中&apos;,&quot;期中&quot;,&quot;期末&quot;,&quot;期末&quot;],</span><br><span class="line">                       [&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;]],</span><br><span class="line">              columns = [&quot;Python&quot;])</span><br></pre></td></tr></table></figure><p>​ (2)显示构造pd.MultiIndex</p><ul><li><p>​ 使用数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df1 = DataFrame(data = np.random.randint(0,150,size = (8,4)),</span><br><span class="line">               index = pd.MultiIndex.from_arrays([[&apos;a&apos;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;],</span><br><span class="line">                       [&apos;期中&apos;,&quot;期中&quot;,&quot;期末&quot;,&quot;期末&quot;,&apos;期中&apos;,&quot;期中&quot;,&quot;期末&quot;,&quot;期末&quot;],</span><br><span class="line">                       [&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;,&quot;一单元&quot;,&quot;二单元&quot;]]),</span><br><span class="line">               columns = [&quot;Python&quot;,&quot;h5&quot;,&quot;php&quot;,&quot;go&quot;])</span><br><span class="line">df1</span><br></pre></td></tr></table></figure></li><li><p>使用tuple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df3 = DataFrame(np.random.randint(0,150,size = 4), </span><br><span class="line">                index = pd.MultiIndex.from_tuples([(&quot;a&quot;,1),(&quot;a&quot;,2),(&quot;b&quot;,1),(&quot;b&quot;,2)]),</span><br><span class="line">               columns = [&quot;Python&quot;])</span><br><span class="line">df3</span><br></pre></td></tr></table></figure></li><li><p>使用product (最简单，推荐使用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df4 = DataFrame(np.random.randint(0,150,size = (8,2)),</span><br><span class="line">                index = pd.MultiIndex.from_product([list(&quot;abcd&quot;), [&quot;期中&quot;,&quot;期末&quot;]]),</span><br><span class="line">               columns = [&apos;Python&apos;,&quot;数学&quot;])</span><br><span class="line">df4</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ol start="2"><li><p>多层列索引</p><p>​ 除了行索引index ,列索引columns也能用同样的方法创建多层索引</p></li><li><p>多层索引对象的索引与切片操作</p><p>​ (1) 对于Series来说：直接中括号[]与使用.loc()完全一样,因此推荐使用中括号索引和括号</p><p>​</p><p>​ <strong>（2）</strong> <strong>DataFrame的操作</strong></p><p>​ . 可以直接使用列名称来进行索引</p><p>​ . 使用行索引需要ix( ) , loc() 函数 推荐使用loc()函数</p><p>注意在对行索引的时候，若一级行索引还有多个，对二级行索引会遇到问题！也就是说，无法直接对二级索引进行索引，必须让二级索引变成一级索引后才能对其进行索引！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df4[&quot;Python&quot;][&quot;a&quot;,&quot;期末&quot;]</span><br><span class="line"></span><br><span class="line">df4.loc[&quot;a&quot;].loc[&quot;期末&quot;][&quot;Python&quot;]</span><br></pre></td></tr></table></figure></li><li><p>索引的堆</p><p>stack( level = * )</p><p>【小技巧】使用stack()的时候，level等于哪一个，哪一个就消失，出现在行里。</p><p>​ unstack()</p><p>​【小技巧】使用unstack()的时候，level等于哪一个，哪一个就消失，出现在列里。</p></li><li><p>聚合操作</p><p>【注意】</p><ul><li><p>需要指定axis</p></li><li><p>【小技巧】和unstack()相反，聚合的时候，axis等于哪一个，哪一个就保留。</p><p>所谓的聚合操作：平均数，方差，最大值，最小值……</p></li></ul><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df4.div(10, axis = &quot;index&quot;)</span><br><span class="line">df4.sum(axis = 1)</span><br><span class="line">df4.std()        #标准差：表示的是数据的离散程度</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>pandas 的拼接操作</p><p>​ 级联 ： pd.concat pd.append(追加，只能行追加)</p><p>​ 合并 ： pd.merge ,pd.join</p><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.concat  = (objs ,axis = 0,join=&apos;outer&apos; ,join_axes=None,ignore_index=False,keys=None,levels=None,names=None,</span><br><span class="line">verify_integrity =False,copy= True)</span><br></pre></td></tr></table></figure><p>| 参数 | 说明 |<br>| —————- | —————————————- |<br>| objs | 参与连接的列表或字典，且列表或字典里的对象是pandas数据类型，唯一必须给定的参数 |<br>| axis=0 | 指明连接的轴向，0是纵轴，1是横轴，默认是0 |<br>| join | ‘inner’（交集）内链接，‘outer’（并集）外连接，默认是‘outer’指明轴向索引的索引是交集还是并集 |<br>| join_axis | 指明用于其他n-1条轴的索引（层次化索引，某个轴向有多个索引），不执行交并集 |<br>| keys | 与连接对象有关的值，用于形成连接轴向上的层次化索引（外层索引），可以是任意值的列表或数组、元组数据、数组列表（如果将levels设置成多级数组的话） |<br>| levels | 指定用作层次化索引各级别（内层索引）上的索引，如果设置keys的话 |<br>| names | 用于创建分层级别的名称，如果设置keys或levels的话 |<br>| verify_integrity | 检查结果对象新轴上的重复情况，如果发横则引发异常，默认False，允许重复 |<br>| ignore_index | 不保留连接轴上的索引，产生一组新索引range（total_length） |</p><p>​</p><p>pd.merge() 函数参数</p><p>一对一，一对多，多对多</p><p>| 参数 | 说明 |<br>| ———– | —————————————- |<br>| left | 参与合并的左侧DataFrame |<br>| right | 参与合并的右侧DataFrame |<br>| how | 连接方式：‘inner’（默认）；还有，‘outer’、‘left’、‘right’ |<br>| on | 用于连接的列名，必须同时存在于左右两个DataFrame对象中，如果位指定，则以left和right列名的交集作为连接键 |<br>| left_on | 左侧DataFarme中用作连接键的列 |<br>| right_on | 右侧DataFarme中用作连接键的列 |<br>| left_index | 将左侧的行索引用作其连接键 |<br>| right_index | 将右侧的行索引用作其连接键 |<br>| sort | 根据连接键对合并后的数据进行排序，默认为True。有时在处理大数据集时，禁用该选项可获得更好的性能 |<br>| suffixes | 字符串值元组，用于追加到重叠列名的末尾，默认为（‘_x’,‘_y’）.例如，左右两个DataFrame对象都有‘data’，则结果中就会出现‘data_x’，‘data_y’ |<br>| | |</p></li></ol><p>​ set_index() 、重新设置行索引</p><p>​ query() 查询</p><h2 id="7-pandas数据处理"><a href="#7-pandas数据处理" class="headerlink" title="7.pandas数据处理"></a>7.pandas数据处理</h2><p>1.删除重复元素</p><p>​ 使用duplicated()函数检测重复的行，返回元素为布尔类型的Series对象，每个元素对应一行，如果该行不是第一次出现，则元素为True</p><p>​ 使用drop_duplicates()函数删除重复的行</p><ol start="2"><li><p>映射</p><p>​ 映射的含义：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定</p><p>需要使用字典：</p><p>map = {</p><pre><code>&apos;label1&apos;:&apos;value1&apos;,&apos;label2&apos;:&apos;value2&apos;,...}</code></pre><p>`</p><p>包含三种操作：</p><ul><li><p>replace()函数：替换元素</p></li><li><p>最重要：map()函数：新建一列</p><p>​ 由已有的列生成新的一列 map()函数中可以使用lambda函数 函数还可以传 一个回调函数 transform()和map()类似</p></li><li><p>rename()函数：替换索引</p></li></ul><p>​</p></li><li><p>异常值检测和处理</p></li></ol><p>​ #对数据进行过滤#std标准差，主要是看数据的稳定性</p><p>​ 删除特定索引df.drop(labels,inplace = True)</p><p>​ 4.排序</p><p>​ (1）使用.take()函数排序，</p><p>​ df. take([2,4,5] ) 根据索引取值</p><p>​ （2) 可以借助np.random.permutation()函数随机排序</p><p>​ (3)当DataFrame规模足够大时，直接使用np.random.randint()函数，就配合take()函数实现随机抽样</p><ol start="5"><li><p><strong>数据聚合【重点】</strong></p><p>数据聚合是数据处理的最后一步，通常是要使每一个数组生成一个单一的数值。</p><p>数据分类处理：</p><ul><li>分组：先把数据分为几组</li><li>用函数处理：为不同组的数据应用不同的函数以转换数据</li><li>合并：把不同组得到的结果合并起来</li></ul><p>数据分类处理的核心：</p><pre><code>groupby()函数 分组            groupby 之后，是聚合操作</code></pre></li><li><p>高级数据集合(不用)</p><p>​ ### 可以使用transform和apply实现相同功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.groupby([&quot;color&quot;]).transform(sum)</span><br><span class="line">df.groupby([&quot;color&quot;])[[&quot;price&quot;,&quot;weight&quot;]].apply(sum)</span><br></pre></td></tr></table></figure></li><li><p>Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线形图(不重)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = Series([80,82,97,89,78,73,66], name = &quot;数学&quot;, index = list(&quot;abcdefg&quot;))</span><br><span class="line">s</span><br><span class="line">线性图： s.plot()         柱状图：s.plot(kind = &quot;bar&quot;)   barh(反向) </span><br><span class="line">横坐标没dx ，不会支持中文</span><br><span class="line"></span><br><span class="line">DataFrame: df.plot()</span><br></pre></td></tr></table></figure><p>直方图</p></li></ol><p>​ 直方图，是一种特殊形状的柱状图 直方图又叫密度图</p><p>​ s.hist(bins = 20)</p><p>​ bins 取值 1:1-1:2</p><p>​ 随机数百分比密度图 s.plot(kind = ‘kde’)#kde 内核： 专门画密度图的</p><p>​ 这两种图表经常被画在一起。直方图以规格化形式给出（以便给出面元化密度），然后再在其上绘制核密度估计。接下来来看一个由两个不同的标准正态分布组成的的双峰分布</p><p>np.random.normal()正太分布函数</p><p>直方图hist，函数中必须添加属性normed = True</p><h2 id="8-scipy"><a href="#8-scipy" class="headerlink" title="8. scipy"></a>8. scipy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scipy.fftpack模块用来计算快速傅里叶变换  </span><br><span class="line">速度比传统傅里叶变换更快，是对之前算法的改进  </span><br><span class="line">图片是二维数据，注意使用fftpack的二维转变方法</span><br></pre></td></tr></table></figure><ol><li>使用傅里叶变换。把数据变成信号数据 fftpack.fft2()</li></ol><p>​ 反向傅里叶变换 fftpack.ifft2()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.real()     plt.figure()   尺寸</span><br></pre></td></tr></table></figure><ol start="2"><li><p>数值积分，求解圆周率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用scipy.integrate进行积分，调用quad()方法</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>scipy文件输入/输出</p><p>​ from scipy import io</p><p>​ 随机生成数组，使用scipy中的io.savemat()保存 文件格式是.mat，标准的二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.savemat(&quot;./1811.mat&quot;, &#123;&quot;nd&quot;:nd&#125;)</span><br><span class="line"></span><br><span class="line">io.loadmat(&quot;./1811.mat&quot;)[&quot;nd&quot;]       读取数据</span><br></pre></td></tr></table></figure></li><li><p>读写图片使用scipy中 misc.imread()/imsave()</p><p>​ misc.imrotate ( ) 旋转图片</p><p>​ .resize() , imfilter()</p></li><li><p>图片处理</p><p>​ ndimage 处理图片的包</p><p>​ 使用scipy.misc.face(gray=True)获取图片，使用ndimage移动坐标、旋转图片、切割图片、 缩放图片</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ndimage.shift()   移动坐标</span><br><span class="line">ndimage.rotate()  旋转图片</span><br><span class="line">ndimage.zoom()    缩放图片</span><br></pre></td></tr></table></figure><ol start="6"><li><p>图片进行过滤</p><p>添加噪声，对噪声图片使用ndimage中的高斯滤波、中值滤波、signal中维纳滤波进行处理<br>使图片变清楚</p></li></ol><h2 id="9-matplotlib"><a href="#9-matplotlib" class="headerlink" title="9.matplotlib"></a>9.matplotlib</h2><ol><li>Matplotlib基础知识： Matplotlib中的基本图表包括的元素</li></ol><ul><li><p>​ x轴和y轴<br>​ 水平和垂直的轴线</p><ul><li><p>​ x轴和y轴刻度<br>​ 刻度标示坐标轴的分隔，包括最小刻度和最大刻度</p><ul><li><p>​ x轴和y轴刻度标签<br>​ 表示特定坐标轴的值</p><ul><li>​ 绘图区域<br>​ 实际绘图的区域</li></ul></li></ul><p>(1) plt.plot(x,y,format_string,**kwargs)</p></li></ul></li></ul><p>​ x轴数据，y轴数据，format_string控制曲线的格式字串</p><p>​ format_string 由颜色字符，风格字符，和标记字符</p><p>​ **kwargs:第二组或更多，(x,y,format_string)</p><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">color:控制颜色，color=’green’   </span><br><span class="line"></span><br><span class="line">linestyle:线条风格，linestyle=’dashed’ </span><br><span class="line"></span><br><span class="line">marker:标记风格，marker = ‘o’ </span><br><span class="line"></span><br><span class="line">markerfacecolor:标记颜色，markerfacecolor = ‘blue’ </span><br><span class="line"></span><br><span class="line">markersize:标记尺寸，markersize = ‘20’</span><br></pre></td></tr></table></figure><p>plt.grid(True) #设置网格线</p><ul><li>lw代表linewidth，线的粗细</li><li><p>alpha表示线的明暗程度</p><p>plt.title() #标题</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fontsize设置字体大小，默认12，可选参数 [&apos;xx-small&apos;, &apos;x-small&apos;, &apos;small&apos;, &apos;medium&apos;, &apos;large&apos;,&apos;x-large&apos;, &apos;xx-large&apos;]</span><br><span class="line">fontweight设置字体粗细，可选参数 [&apos;light&apos;, &apos;normal&apos;, &apos;medium&apos;, &apos;semibold&apos;, &apos;bold&apos;, &apos;heavy&apos;, &apos;black&apos;]</span><br><span class="line">fontstyle设置字体类型，可选参数[ &apos;normal&apos; | &apos;italic&apos; | &apos;oblique&apos; ]，italic斜体，oblique倾斜</span><br><span class="line">verticalalignment设置水平对齐方式 ，可选参数 ： &apos;center&apos; , &apos;top&apos; , &apos;bottom&apos; ,&apos;baseline&apos; </span><br><span class="line">horizontalalignment设置垂直对齐方式，可选参数：left,right,center</span><br><span class="line">rotation(旋转角度)可选参数为:vertical,horizontal 也可以为数字</span><br><span class="line">alpha透明度，参数值0至1之间</span><br><span class="line">backgroundcolor标题背景颜色</span><br><span class="line">bbox给标题增加外框 ，常用参数如下：</span><br><span class="line">   boxstyle方框外形</span><br><span class="line">   facecolor(简写fc)背景颜色</span><br><span class="line">   edgecolor(简写ec)边框线条颜色</span><br><span class="line">   edgewidth边框线条大小</span><br></pre></td></tr></table></figure><p>plt.xlabel()/ylabel() #设置轴标签 参数：rotation 旋转度数</p><p>plt.legend(loc=’upper left’) #设置legend显示，并指定位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">| 字符串       | 数值      | 字符串   |  数值 |</span><br><span class="line">| :-------------: |:-----------:| :-----:|  :-----:|</span><br><span class="line">| best        |  0        | center left   |   6 |</span><br><span class="line">| upper right    | 1        | center right  |   7  |</span><br><span class="line">| upper left    |  2        | lower center  |   8  |</span><br><span class="line">| lower left    |  3        | upper center  |   9 |</span><br><span class="line">| lower right   |  4        | center      |   10 |</span><br><span class="line">| right       |  5        |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ncol控制图例中有几列</span><br><span class="line"> mode = （可拉伸的）</span><br><span class="line"> bbox_to_anchor    (锚点)  例子： bbox_to_anchor= [o,2,1,0.1]  前两个值是坐标点，第三个值宽度，最后一个是距离y轴的距离       </span><br><span class="line"> facecolor  背景颜色</span><br></pre></td></tr></table></figure><p>plt.show() #显示图像</p><p>设置坐标轴范围</p><p>除了plt.axis方法，还可以通过xlim，ylim方法设置坐标轴范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加子视图</span><br><span class="line">axes1 = figure.add_subplot(1,3,1)     #表示一行三列第一个</span><br></pre></td></tr></table></figure><p>​ 不同程度的破折线</p><p>​ dashes =[ ] #注意偶数</p><p>​</p><p>（2）保存图片</p><p>​ plt.savefig()</p><p>（3）三种设置方式</p><p>​ 1.向方法传入关键字参数</p><p>​ 2.使用setp()方法</p><p>​ 3 .对实例使用一系列的setter方法</p><p>(4) x,y轴坐标刻度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locs, labels = plt.xticks() # 不传入任何参数，xticks()会返回当前刻度的位置和标签</span><br><span class="line"></span><br><span class="line">Π，α，β，----》 [&quot;$\pi$&quot;]</span><br></pre></td></tr></table></figure><ol start="2"><li><p>2D图形</p><p>(1) 直方图</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Jan 25 2019 13:11:42 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;数据分析&quot;&gt;&lt;a href=&quot;#数据分析&quot; class=&quot;headerlink&quot; title=&quot;数据分析&quot;&gt;&lt;/a&gt;数据分析&lt;/h1&gt;&lt;h2 id=&quot;1-工具&quot;&gt;&lt;a href=&quot;#1-工具&quot; class=&quot;headerlink&quot; title=&quot;1.工具&quot;&gt;&lt;/a&gt;1.工具&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Jupyter Notebook&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;运行命令 ：jupyter notebook&lt;/p&gt;&lt;p&gt;快捷键：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Enter&lt;/strong&gt; : 转入编辑模式&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Shift-Enter&lt;/strong&gt; : 运行本单元，选中下个单元&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Ctrl-Enter&lt;/strong&gt; : 运行本单元&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Alt-Enter&lt;/strong&gt; : 运行本单元，在其下插入新单元&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt; : 在上方插入新单元&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https//linchao1002.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https//linchao1002.github.io/tags/Python/"/>
    
      <category term="数据分析" scheme="https//linchao1002.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="numpy" scheme="https//linchao1002.github.io/tags/numpy/"/>
    
      <category term="matoplotlib可视化" scheme="https//linchao1002.github.io/tags/matoplotlib%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="pandas" scheme="https//linchao1002.github.io/tags/pandas/"/>
    
  </entry>
  
</feed>
